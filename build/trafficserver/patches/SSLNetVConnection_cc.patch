--- iocore/net/SSLNetVConnection.cc     (revision 1196714)
+++ iocore/net/SSLNetVConnection.cc     (working copy)
@@ -33,6 +33,7 @@
 #define SSL_HANDSHAKE_WANT_WRITE  7
 #define SSL_HANDSHAKE_WANT_ACCEPT 8
 #define SSL_HANDSHAKE_WANT_CONNECT 9
+#define SSL_WRITE_WOULD_BLOCK     10
 ClassAllocator<SSLNetVConnection> sslNetVCAllocator("sslNetVCAllocator");
 
 
@@ -99,10 +100,13 @@
         continue;
 
       case SSL_ERROR_WANT_WRITE:
+        event = SSL_WRITE_WOULD_BLOCK;
+        Debug("ssl", "[SSL_NetVConnection::ssl_read_from_net] SSL_ERROR_WOULD_BLOCK(write)");
+        break;
       case SSL_ERROR_WANT_READ:
       case SSL_ERROR_WANT_X509_LOOKUP:
         event = SSL_READ_WOULD_BLOCK;
-        Debug("ssl", "[SSL_NetVConnection::ssl_read_from_net] SSL_ERROR_WOULD_BLOCK");
+        Debug("ssl", "[SSL_NetVConnection::ssl_read_from_net] SSL_ERROR_WOULD_BLOCK(read)");
         break;
       case SSL_ERROR_SYSCALL:
         if (rres != 0) {
@@ -197,12 +201,14 @@
     if (ret == EVENT_ERROR) {
       this->read.triggered = 0;
       readSignalError(nh, err);
-    } else if (ret == SSL_HANDSHAKE_WANT_READ || ret == SSL_HANDSHAKE_WANT_ACCEPT || ret == SSL_HANDSHAKE_WANT_CONNECT
-               || ret == SSL_HANDSHAKE_WANT_WRITE) {
+    } else if (ret == SSL_HANDSHAKE_WANT_READ || ret == SSL_HANDSHAKE_WANT_ACCEPT) {
       read.triggered = 0;
       nh->read_ready_list.remove(this);
+      readReschedule(nh);
+    } else if (ret == SSL_HANDSHAKE_WANT_CONNECT || ret == SSL_HANDSHAKE_WANT_WRITE) {
       write.triggered = 0;
       nh->write_ready_list.remove(this);
+      writeReschedule(nh);
     } else if (ret == EVENT_DONE) {
       read.triggered = 1;
       if (read.enabled)
@@ -244,10 +250,12 @@
     // how did we exit the while loop above? should never happen.
     ink_debug_assert(false);
     break;
+  case SSL_WRITE_WOULD_BLOCK:
   case SSL_READ_WOULD_BLOCK:
     if (lock.m.m_ptr != s->vio.mutex.m_ptr) {
       Debug("ssl", "ssl_read_from_net, mutex switched");
-      readReschedule(nh);
+      if(ret == SSL_READ_WOULD_BLOCK) readReschedule(nh);
+      else writeReschedule(nh);
       return;
     }
     // reset the tigger and remove from the ready queue
@@ -255,6 +263,10 @@
     read.triggered = 0;
     nh->read_ready_list.remove(this);
     Debug("ssl", "read_from_net, read finished - would block");
+#ifdef TS_USE_PORT
+    if(ret == SSL_READ_WOULD_BLOCK) readReschedule(nh);
+    else writeReschedule(nh);
+#endif
     break;
 
   case SSL_READ_EOS:
