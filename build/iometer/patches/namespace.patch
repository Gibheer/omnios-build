--- iometer-1.1.0-rc1/src/IOGrunt.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOGrunt.cpp	Mon Aug 20 18:18:46 2012
@@ -327,7 +327,7 @@
 #endif
 	{
 		Free_Transaction_Arrays();
-		cout << "*** Grunt could not allocate transaction request list." << endl;
+		std::cout << "*** Grunt could not allocate transaction request list." << std::endl;
 		return FALSE;
 	}
 	trans_slots = (Transaction *) new_mem;
@@ -345,7 +345,7 @@
 #endif
 	{
 		Free_Transaction_Arrays();
-		cout << "*** Grunt could not allocate available queue." << endl;
+		std::cout << "*** Grunt could not allocate available queue." << std::endl;
 		return FALSE;
 	}
 	available_trans_queue = (int *)new_mem;
@@ -438,7 +438,7 @@
 
 	// If no targets are being set, simply clear the target list.
 	if (!count) {
-		cout << "   clearing target list." << endl;
+		std::cout << "   clearing target list." << std::endl;
 		return Size_Target_Array(0);
 	}
 	// Allocate enough targets
@@ -462,7 +462,7 @@
 	{
 		// Create completion queue and verify its creation.
 		if (!(io_cq = new CQAIO)) {
-			cout << "*** Unable to create completion queue while setting " << "targets." << endl;
+			std::cout << "*** Unable to create completion queue while setting " << "targets." << std::endl;
 			return FALSE;
 		}
 	}
@@ -477,7 +477,7 @@
 	// Seed the random number generator.  Grunts transferring data over a
 	// network will use the same seed to produce the same sequence of random
 	// numbers.  This will keep them in synch.
-	cout << "Seeding random Number Generator(" << target_specs[0].random << ")" << endl;
+	std::cout << "Seeding random Number Generator(" << target_specs[0].random << ")" << std::endl;
 	Srand(target_specs[0].random);
 
 	return Resize_Transaction_Arrays();
@@ -559,8 +559,8 @@
 	// transfer.  We do this only if the current buffer is too small and
 	// we're using per worker data buffers.
 	if (data_size >= access_spec.max_transfer) {
-		cout << "Grunt: Grunt data buffer size " << data_size << " >= "
-		    << access_spec.max_transfer << ", returning" << endl;
+		std::cout << "Grunt: Grunt data buffer size " << data_size << " >= "
+		    << access_spec.max_transfer << ", returning" << std::endl;
 		return TRUE;
 	} else if (!data_size) {
 		// We always want to use our own buffers, not the manager's
@@ -574,12 +574,12 @@
 		// aren't thrashing on the same buffer for both read and
 		// write operations.
 		data_size = access_spec.max_transfer;
-		cout << "Grunt: Growing grunt data buffer from " << data_size << " to "
-		    << access_spec.max_transfer << endl;
+		std::cout << "Grunt: Growing grunt data buffer from " << data_size << " to "
+		    << access_spec.max_transfer << std::endl;
 	}
 	// Allocating a larger buffer.
 #ifdef _DEBUG
-	cout << "Growing grunt data buffers from " << data_size << " to " << access_spec.max_transfer << endl;
+	std::cout << "Growing grunt data buffers from " << data_size << " to " << access_spec.max_transfer << std::endl;
 #endif
 
 #if defined(IOMTR_OSFAMILY_NETWARE)
@@ -611,7 +611,7 @@
 #endif
 	{
 		// Could not allocate a larger buffer.  Signal failure.
-		cout << "*** Grunt could not allocate read data buffer for I/O transfers." << endl;
+		std::cout << "*** Grunt could not allocate read data buffer for I/O transfers." << std::endl;
 		data_size = 0;
 		return FALSE;
 	}
@@ -645,7 +645,7 @@
 #endif
 	{
 		// Could not allocate a larger buffer.  Signal failure.
-		cout << "*** Grunt could not allocate write data buffer for I/O transfers." << endl;
+		std::cout << "*** Grunt could not allocate write data buffer for I/O transfers." << std::endl;
 		data_size = 0;
 		return FALSE;
 	}
@@ -702,8 +702,8 @@
 #endif
 
 #ifdef _DETAILS
-			cout << "Worker " << worker_index << ", setting thread affinity mask to " 
-				 << hex << effective_affinity << endl;
+			std::cout << "Worker " << worker_index << ", setting thread affinity mask to " 
+				 << hex << effective_affinity << std::endl;
 #endif
 			break;
 		}
@@ -734,7 +734,7 @@
 	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(long)&not_ready, (long)target_count);
 
 	// Creating a thread to prepare each disk.
-	cout << "Preparing disks..." << endl;
+	std::cout << "Preparing disks..." << std::endl;
 
 #if defined(IOMTR_OSFAMILY_NETWARE)
 	prepare_thread = (Thread_Info *) NXMemAlloc(sizeof(Thread_Info) * target_count, 1);
@@ -744,7 +744,7 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	if (!prepare_thread) {
-		cout << "*** Unable to allocate memory for preparation threads." << endl;
+		std::cout << "*** Unable to allocate memory for preparation threads." << std::endl;
 		return FALSE;
 	};
 
@@ -752,7 +752,7 @@
 		if (IsType(targets[i]->spec.type, LogicalDiskType)) {
 			prepare_thread[i].parent = this;
 			prepare_thread[i].id = i;
-			cout << "   " << targets[i]->spec.name << " preparing." << endl;
+			std::cout << "   " << targets[i]->spec.name << " preparing." << std::endl;
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
 			// Assuming that thr_create call will not fail !!!
 
@@ -810,7 +810,7 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
-		cout << "*** Could not allocate buffer to prepare disk." << endl;
+		std::cout << "*** Could not allocate buffer to prepare disk." << std::endl;
 		critical_error = TRUE;
 		InterlockedDecrement(IOMTR_MACRO_INTERLOCK_CAST(long) & not_ready);
 
@@ -838,13 +838,13 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
-		cout << "*** Could not open disk." << endl;
+		std::cout << "*** Could not open disk." << std::endl;
 		critical_error = TRUE;
 	}
 	else {
 		// Prepare the disk, first with large block sizes, then with single sectors.
 		if (!disk->Prepare(&prepare_offset, &grunt_state, disk->spec.disk_info.sector_size, random_data_buffer, random_data_buffer_size)) {
-			cout << "*** An error occurred while preparing the disk." << endl;
+			std::cout << "*** An error occurred while preparing the disk." << std::endl;
 			critical_error = TRUE;
 		}
 
@@ -860,7 +860,7 @@
 #else
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
-	cout << "   " << disk->spec.name << " done." << endl;
+	std::cout << "   " << disk->spec.name << " done." << std::endl;
 	InterlockedDecrement(IOMTR_MACRO_INTERLOCK_CAST(long) & not_ready);
 }
 
@@ -976,10 +976,10 @@
 #ifdef _DEBUG
 	else {
 		if (transaction->remaining_requests < 0)
-			cout << "*** ERROR: remaining_requests is negative" << endl;
+			std::cout << "*** ERROR: remaining_requests is negative" << std::endl;
 
 		if (transaction->remaining_replies < 0)
-			cout << "*** ERROR: remaining_replies is negative" << endl;
+			std::cout << "*** ERROR: remaining_replies is negative" << std::endl;
 	}
 #endif
 
@@ -1049,16 +1049,16 @@
 	int i;
 
 	// Opening all targets for access.
-	cout << "   Opening targets." << endl;
+	std::cout << "   Opening targets." << std::endl;
 	for (i = 0; i < target_count; i++) {
 		// All targets are opened to ensure that they can connect.
 		if (!targets[i]->Open(&grunt_state)) {
 			// An error occurred opening a target.  Do not go any further.
-			cout << "*** Error opening " << targets[i]->spec.name << endl;
+			std::cout << "*** Error opening " << targets[i]->spec.name << std::endl;
 			break;
 		}
 #if _DETAILS
-		cout << "Opened " << targets[i]->spec.name << endl;
+		std::cout << "Opened " << targets[i]->spec.name << std::endl;
 #endif
 
 		// If the target is testing connection rate, it will be opened when
@@ -1066,10 +1066,10 @@
 		if (targets[i]->spec.test_connection_rate) {
 			targets[i]->trans_left_in_conn = 0;
 #ifdef _DEBUG
-			cout << "Defering open for " << targets[i]->spec.name << endl;
+			std::cout << "Defering open for " << targets[i]->spec.name << std::endl;
 #endif
 			if (!targets[i]->Close(&grunt_state)) {
-				cout << "*** Error re-closing target " << targets[i]->spec.name << endl;
+				std::cout << "*** Error re-closing target " << targets[i]->spec.name << std::endl;
 				break;
 			}
 		}
@@ -1094,7 +1094,7 @@
 	// Closing disks.
 	for (int i = 0; i < target_count; i++) {
 		if (!(targets[i]->Close(&grunt_state)))
-			cout << "*** Error closing " << targets[i]->spec.name << endl;
+			std::cout << "*** Error closing " << targets[i]->spec.name << std::endl;
 	}
 	InterlockedExchange(IOMTR_MACRO_INTERLOCK_CAST(long) & not_ready, 0);
 }
@@ -1166,7 +1166,7 @@
 			// until all outstanding I/Os have completed.
 			if (target->outstanding_ios == 0) {
 #ifdef _DEBUG
-				cout << "Testing connection rate: Closing " << targets[target_id]->spec.name << endl;
+				std::cout << "Testing connection rate: Closing " << targets[target_id]->spec.name << std::endl;
 #endif
 
 				// Close target and record connection time.
@@ -1196,7 +1196,7 @@
 		// Check to see if we need to open the target.
 		if (target->spec.test_connection_rate && target->trans_left_in_conn <= 0) {
 #ifdef _DEBUG
-			cout << "Testing connection rate: Opening " << target->spec.name << endl;
+			std::cout << "Testing connection rate: Opening " << target->spec.name << std::endl;
 #endif
 			// Set the number of transactions to do before closing.
 			target->trans_left_in_conn = target->spec.trans_per_conn;
@@ -1367,7 +1367,7 @@
 			// see whether it should record the error
 			if (grunt_state == TestRecording) {
 				// ERROR: The I/O was not queued successfully.
-				cout << "*** Error performing I/O to " << target->spec.name << endl;
+				std::cout << "*** Error performing I/O to " << target->spec.name << std::endl;
 
 				if (transaction->is_read)
 					worker_performance.target_results.result[target_id].read_errors++;
@@ -1400,7 +1400,7 @@
 
 		switch (Complete_IO(TIMEOUT_TIME)) {
 		case ReturnTimeout:
-			cout << "*** Grunt thread exiting with " << outstanding_ios << " still active" << endl;
+			std::cout << "*** Grunt thread exiting with " << outstanding_ios << " still active" << std::endl;
 			break;
 		default:
 			break;
@@ -1452,8 +1452,8 @@
 	transaction->size -= bytes_done;
 
 #if _DETAILS
-	cout << "Doing another " << (transaction->is_read ? "read" : "write")
-	    << " for the remaining " << transaction->size << " bytes." << endl;
+	std::cout << "Doing another " << (transaction->is_read ? "read" : "write")
+	    << " for the remaining " << transaction->size << " bytes." << std::endl;
 #endif
 
 	if (transaction->is_read) {
@@ -1464,7 +1464,7 @@
 
 	if ((result != ReturnSuccess) && (result != ReturnPending) && (grunt_state == TestRecording)) {
 		// The I/O was not started successfully.
-		cout << "*** ERROR performing read or write to " << targets[transaction->target_id]->spec.name << endl;
+		std::cout << "*** ERROR performing read or write to " << targets[transaction->target_id]->spec.name << std::endl;
 
 		if (transaction->is_read)
 			worker_performance.target_results.result[transaction->target_id].read_errors++;
--- iometer-1.1.0-rc1/src/NetVI.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/NetVI.cpp	Mon Aug 20 18:18:45 2012
@@ -89,7 +89,7 @@
 	VIP_RETURN result;
 
 #if VI_DETAILS
-	cout << "Creating VI on nic " << nic->nic_attributes.Name << endl;
+	std::cout << "Creating VI on nic " << nic->nic_attributes.Name << std::endl;
 #endif
 
 	// Create the VI completion queue for the specified VI NIC.
@@ -107,7 +107,7 @@
 	// Create the virtual interface.
 	result = vipl.VipCreateVi(nic->nic, &vi_attributes, vi_cq.completion_queue, vi_cq.completion_queue, &vi);
 	if (result != VIP_SUCCESS) {
-		cout << "*** Unable to create VI: " << vipl.Error(result) << endl;
+		std::cout << "*** Unable to create VI: " << vipl.Error(result) << std::endl;
 		vi_cq.Destroy();
 		return ReturnError;
 	}
@@ -114,7 +114,7 @@
 	// Get the VI attributes that were actually assigned.
 	if ((result = vipl.VipQueryVi(vi, &vi_state, &vi_attributes,
 				      &send_queue_empty, &receive_queue_empty)) != VIP_SUCCESS) {
-		cout << "*** Unable to retrieve VI attributes: " << vipl.Error(result) << endl;
+		std::cout << "*** Unable to retrieve VI attributes: " << vipl.Error(result) << std::endl;
 		vipl.VipDestroyVi(&vi);
 		vi_cq.Destroy();
 		return ReturnError;
@@ -133,7 +133,7 @@
 	VIP_RETURN result;
 
 #if VI_DETAILS
-	cout << "Closing VI on " << vi_nic->nic_attributes.Name << endl;
+	std::cout << "Closing VI on " << vi_nic->nic_attributes.Name << std::endl;
 #endif
 
 	// See if the VI exists.  If it doesn't, we're done.
@@ -142,7 +142,7 @@
 
 	// Disconnect the VI.  This will mark all outstanding requests as complete.
 	if ((result = vipl.VipDisconnect(vi)) != VIP_SUCCESS) {
-		cout << "*** Unable to disconnect VI while closing: " << vipl.Error(result) << endl;
+		std::cout << "*** Unable to disconnect VI while closing: " << vipl.Error(result) << std::endl;
 		return ReturnError;
 	}
 	// Remove outstanding requests from the completion queue.
@@ -157,12 +157,12 @@
 
 	// Destroy the VI.
 	if ((result = vipl.VipDestroyVi(vi)) != VIP_SUCCESS) {
-		cout << "*** Unable to destroy VI while closing: " << vipl.Error(result) << endl;
+		std::cout << "*** Unable to destroy VI while closing: " << vipl.Error(result) << std::endl;
 		return ReturnError;
 	}
 	// Destroy the associated completion queue.
 	if (!vi_cq.Destroy()) {
-		cout << "*** Unable to destroy VI completion queue." << endl;
+		std::cout << "*** Unable to destroy VI completion queue." << std::endl;
 		return ReturnError;
 	}
 
@@ -208,7 +208,7 @@
 	VIP_CONN_HANDLE connection;
 
 #if VI_DETAILS
-	cout << "Waiting to accept VI connection on " << vi_nic->nic_attributes.Name << endl;
+	std::cout << "Waiting to accept VI connection on " << vi_nic->nic_attributes.Name << std::endl;
 #endif
 
 	// Waiting until the client can connect.
@@ -217,22 +217,22 @@
 		// Client ready to connect, accept the connection.
 	case VIP_SUCCESS:
 #if VI_DETAILS
-		cout << "VipConnectWait succeeded!  Accepting connection." << endl;
+		std::cout << "VipConnectWait succeeded!  Accepting connection." << std::endl;
 #endif
 		switch (result = vipl.VipConnectAccept(connection, vi)) {
 		case VIP_SUCCESS:
 #if VI_DETAILS
-			cout << "VipConnectAccept succeeded!" << endl;
+			std::cout << "VipConnectAccept succeeded!" << std::endl;
 #endif
 			return ReturnSuccess;
 		case VIP_TIMEOUT:
 		case VIP_ERROR_RESOURCE:
 #if VI_DETAILS
-			cout << "VipConnectAccept() failed (trying again): " << vipl.Error(result) << endl;
+			std::cout << "VipConnectAccept() failed (trying again): " << vipl.Error(result) << std::endl;
 #endif
 			return ReturnRetry;
 		default:
-			cout << "*** VipConnectAccept() failed: " << vipl.Error(result) << endl;
+			std::cout << "*** VipConnectAccept() failed: " << vipl.Error(result) << std::endl;
 			return ReturnError;
 		}
 
@@ -240,11 +240,11 @@
 	case VIP_TIMEOUT:
 	case VIP_ERROR_RESOURCE:
 #if VI_DETAILS
-		cout << "VipConnectWait() failed (trying again): " << vipl.Error(result) << endl;
+		std::cout << "VipConnectWait() failed (trying again): " << vipl.Error(result) << std::endl;
 #endif
 		return ReturnRetry;
 	default:
-		cout << "*** VipConnectWait() failed: " << vipl.Error(result) << endl;
+		std::cout << "*** VipConnectWait() failed: " << vipl.Error(result) << std::endl;
 		return ReturnError;
 	}
 }
@@ -260,7 +260,7 @@
 	VIP_VI_ATTRIBUTES remote_vi_attributes;
 
 #if VI_DETAILS
-	cout << "Requesting VI connection from " << vi_nic->nic_attributes.Name << endl;
+	std::cout << "Requesting VI connection from " << vi_nic->nic_attributes.Name << std::endl;
 #endif
 
 	// Request to connect to a remote VI.
@@ -268,7 +268,7 @@
 						remote_nic_address, RETRY_DELAY, &remote_vi_attributes)) {
 	case VIP_SUCCESS:
 #if VI_DETAILS
-		cout << "VipConnectRequest succeeded!" << endl;
+		std::cout << "VipConnectRequest succeeded!" << std::endl;
 #endif
 		return ReturnSuccess;
 	case VIP_TIMEOUT:
@@ -276,11 +276,11 @@
 	case VIP_ERROR_RESOURCE:
 	case VIP_REJECT:
 #if VI_DETAILS
-		cout << "VipConnectRequest() failed (trying again): " << vipl.Error(result) << endl;
+		std::cout << "VipConnectRequest() failed (trying again): " << vipl.Error(result) << std::endl;
 #endif
 		return ReturnRetry;
 	default:
-		cout << "*** VipConnectRequest() failed: " << vipl.Error(result) << endl;
+		std::cout << "*** VipConnectRequest() failed: " << vipl.Error(result) << std::endl;
 		return ReturnError;
 	}
 }
@@ -293,12 +293,12 @@
 	VIP_RETURN result;
 
 #if VI_DETAILS
-	cout << "Sending " << descriptor->CS.Length << " bytes over VI NIC " << vi_nic->nic_attributes.Name << endl;
+	std::cout << "Sending " << descriptor->CS.Length << " bytes over VI NIC " << vi_nic->nic_attributes.Name << std::endl;
 #endif
 
 	// Send the I/O request.
 	if ((result = vipl.VipPostSend(vi, descriptor, descriptor_handle)) != VIP_SUCCESS) {
-		cout << "*** Unable to post VI send: " << vipl.Error(result) << endl;
+		std::cout << "*** Unable to post VI send: " << vipl.Error(result) << std::endl;
 		return ReturnError;
 	}
 	return ReturnSuccess;
@@ -312,12 +312,12 @@
 	VIP_RETURN result;
 
 #if VI_DETAILS
-	cout << "Receiving " << descriptor->CS.Length << " bytes over VI NIC " << vi_nic->nic_attributes.Name << endl;
+	std::cout << "Receiving " << descriptor->CS.Length << " bytes over VI NIC " << vi_nic->nic_attributes.Name << std::endl;
 #endif
 
 	// Send the I/O request.
 	if ((result = vipl.VipPostRecv(vi, descriptor, descriptor_handle)) != VIP_SUCCESS) {
-		cout << "*** Unable to post VI receive: " << vipl.Error(result) << endl;
+		std::cout << "*** Unable to post VI receive: " << vipl.Error(result) << std::endl;
 		return ReturnError;
 	}
 	return ReturnSuccess;
--- iometer-1.1.0-rc1/src/IOTargetTCP.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOTargetTCP.cpp	Mon Aug 20 18:18:45 2012
@@ -89,7 +89,7 @@
 		// Target is a server - local connection is a client.
 		return InitClient(target_info);
 	} else {
-		cout << "***Invalid target type in TargetTCP::Initialize()." << endl;
+		std::cout << "***Invalid target type in TargetTCP::Initialize()." << std::endl;
 		return FALSE;
 	}
 }
@@ -112,7 +112,7 @@
 	tcp_socket.SetAddress(SERVER, spec.name);
 	// Create and bind the server socket.
 	if (tcp_socket.Create(SERVER) != ReturnSuccess) {
-		cout << "*** Failed to create a TCP server port." << endl;
+		std::cout << "*** Failed to create a TCP server port." << std::endl;
 		target_info->tcp_info.local_port = USHRT_MAX;
 		return FALSE;
 	}
@@ -140,12 +140,12 @@
 
 	// Create and bind the client socket.
 #ifdef _DEBUG
-	cout << "Creating socket " << spec.name << "." << endl << flush;
+	std::cout << "Creating socket " << spec.name << "." << std::endl << std::flush;
 #endif
 
 	// Make sure we can create the socket.
 	if (tcp_socket.Create(CLIENT) != ReturnSuccess) {
-		cout << "*** Failed to create TCP client socket." << endl;
+		std::cout << "*** Failed to create TCP client socket." << std::endl;
 		spec.tcp_info.local_port = USHRT_MAX;
 		return FALSE;
 	}
@@ -182,7 +182,7 @@
 		while (result == ReturnRetry && *test_state != TestIdle);
 
 		if (result == ReturnError) {
-			cout << "*** Unable to accept connection opening TCP target." << endl;
+			std::cout << "*** Unable to accept connection opening TCP target." << std::endl;
 			return FALSE;
 		}
 	} else {
@@ -206,7 +206,7 @@
 
 				tcp_socket.Close(CLIENT);
 				if (tcp_socket.Create(CLIENT) != ReturnSuccess) {
-					cout << "*** Failed to re-create TCP client socket." << endl;
+					std::cout << "*** Failed to re-create TCP client socket." << std::endl;
 					return FALSE;
 				}
 			}
@@ -215,7 +215,7 @@
 		while (result == ReturnRetry && *test_state != TestIdle);
 
 		if (result == ReturnError) {
-			cout << "*** Unable to connect to server opening TCP target." << endl;
+			std::cout << "*** Unable to connect to server opening TCP target." << std::endl;
 			return FALSE;
 		}
 	}
--- iometer-1.1.0-rc1/src/GalileoView.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/GalileoView.cpp	Mon Aug 20 18:18:46 2012
@@ -1025,7 +1025,7 @@
 		if ((m_pPageSetup->result_type != RecordNone) && !result_file.IsEmpty()) {
 			ofstream file(result_file, ios::app);
 
-			file << "Aborted test" << endl;
+			file << "Aborted test" << std::endl;
 			file.close();
 		}
 		TestDone(test_successful);
@@ -1111,7 +1111,7 @@
 		if ((m_pPageSetup->result_type != RecordNone) && !result_file.IsEmpty()) {
 			ofstream file(result_file, ios::app);
 
-			file << "'End Test" << endl;
+			file << "'End Test" << std::endl;
 			file.close();
 		}
 		m_pPageAccess->MarkAccesses(access_index);
@@ -1251,7 +1251,7 @@
 	if (flags[ICFManagerWorkerFlag]) {
 		// Manager configuration is being restored,
 
-		// Prepare a map of which saved managers should
+		// Prepare a std::map of which saved managers should
 		// be restored to which managers logged into Iometer.
 		theApp.manager_list.loadmap.Reset();
 
@@ -1377,7 +1377,7 @@
 		return FALSE;
 	}
 
-	outfile << pVersion << endl;
+	outfile << pVersion << std::endl;
 
 	if (flags[ICFTestSetupFlag]) {
 		// Save test setup tab settings.
@@ -1385,8 +1385,8 @@
 		m_pPageSetup->UpdateData(TRUE);	// copy GUI data to variables
 
 		if (!m_pPageSetup->SaveConfig(outfile)) {
-			outfile << pVersion << endl;
-			outfile << "Error while writing test setup" << endl;
+			outfile << pVersion << std::endl;
+			outfile << "Error while writing test setup" << std::endl;
 			outfile.close();
 			return FALSE;
 		}
@@ -1398,8 +1398,8 @@
 		m_pPageDisplay->UpdateData(TRUE);	// copy GUI data to variables
 
 		if (!m_pPageDisplay->SaveConfig(outfile)) {
-			outfile << pVersion << endl;
-			outfile << "Error while writing results display" << endl;
+			outfile << pVersion << std::endl;
+			outfile << "Error while writing results display" << std::endl;
 			outfile.close();
 			return FALSE;
 		}
@@ -1409,8 +1409,8 @@
 		// Save global access specification list.
 
 		if (!theApp.access_spec_list.SaveConfig(outfile)) {
-			outfile << pVersion << endl;
-			outfile << "Error while writing global access spec list" << endl;
+			outfile << pVersion << std::endl;
+			outfile << "Error while writing global access spec list" << std::endl;
 			outfile.close();
 			return FALSE;
 		}
@@ -1420,14 +1420,14 @@
 		// Save manager/worker configuration.
 
 		if (!theApp.manager_list.SaveConfig(outfile, flags[ICFAssignedAspecFlag], flags[ICFAssignedTargetFlag])) {
-			outfile << pVersion << endl;
-			outfile << "Error while writing manager/worker configuration" << endl;
+			outfile << pVersion << std::endl;
+			outfile << "Error while writing manager/worker configuration" << std::endl;
 			outfile.close();
 			return FALSE;
 		}
 	}
 
-	outfile << pVersion << endl;
+	outfile << pVersion << std::endl;
 	outfile.close();
 
 	return TRUE;
@@ -2350,7 +2350,7 @@
 //
 // The OnMDisplay...() functions are called in response to a selection from the 
 // IDR_POPUP_DISPLAY_LIST menu, which is popped up by the function CPageDisplay::OnBResultType(). 
-// The main purpose of this group of functions is to map menu item IDs to *_RESULT constants.
+// The main purpose of this group of functions is to std::map menu item IDs to *_RESULT constants.
 //
 // IDR_POPUP_DISPLAY_LIST menu item ID's have the following format:
 //
--- iometer-1.1.0-rc1/src/Network.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/Network.cpp	Mon Aug 20 18:18:46 2012
@@ -67,7 +67,7 @@
 /* ##               2003-02-15 (daniel.scheibli@edelbyte.org)             ## */
 /* ##               - Added new header holding the changelog.             ## */
 /* ##               - Different changes to support compilation with       ## */
-/* ##                 gcc 3.2 (known as cout << hex error).               ## */
+/* ##                 gcc 3.2 (known as std::cout << hex error).               ## */
 /* ##                                                                     ## */
 /* ######################################################################### */
 
@@ -83,7 +83,7 @@
 
 Network::Network()
 {
-	errmsg = new ostringstream;
+	errmsg = new std::ostringstream;
 }
 
 Network::~Network()
@@ -98,8 +98,8 @@
 void Network::OutputErrMsg()
 {
 	if (!errmsg) {
-		errmsg = new ostringstream;
-		*errmsg << "Port::OutputErrMsg() called with invalid errmsg value!" << ends;
+		errmsg = new std::ostringstream;
+		*errmsg << "Port::OutputErrMsg() called with invalid errmsg value!" << std::ends;
 	}
 #if defined(_GALILEO_)
 	// Iometer
@@ -106,7 +106,7 @@
 	ErrorMessage(errmsg->str().c_str());
 #else
 	// Dynamo
-	cout << errmsg->str() << endl;
+	std::cout << errmsg->str() << std::endl;
 #endif
 
 	// str() returns pointer to buffer and freezes it, we must call freeze(FALSE) to 
@@ -113,10 +113,10 @@
 	// unfreeze the buffer before we can delete the object
 	// ---
 	// REMARK: freeze() no longer needed because new are now
-	// using ostringstream instead of ostrstream.   
+	// using std::ostringstream instead of ostrstream.   
 	//
 	// errmsg->rdbuf()->freeze( FALSE );
 	delete errmsg;
 
-	errmsg = new ostringstream;
+	errmsg = new std::ostringstream;
 }
--- iometer-1.1.0-rc1/src/IOCommon.h.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOCommon.h	Mon Aug 20 18:18:41 2012
@@ -138,7 +138,7 @@
 /* ##                 types are no longer hard coded.                     ## */
 /* ##               2003-02-15 (daniel.scheibli@edelbyte.org)             ## */
 /* ##               - Different changes to support compilation with       ## */
-/* ##                 gcc 3.2 (known as cout << hex error).               ## */
+/* ##                 gcc 3.2 (known as std::cout << hex error).               ## */
 /* ##               2003-02-08 (daniel.scheibli@edelbyte.org)             ## */
 /* ##               - Added ULONG_PTR and DWORD_PTR typedef to the        ## */
 /* ##                 Windows part to get compiled.                       ## */
@@ -232,7 +232,6 @@
 // ----------------------------------------------------------------------------
 #include <iostream>
 #include <fstream>
-using namespace std;
 // ----------------------------------------------------------------------------
 #if defined(IOMTR_OSFAMILY_NETWARE)
  #include <sys/timeval.h>
@@ -1019,13 +1018,13 @@
  #define LOCK					    \
 	 if (pthread_mutex_lock(&lock_mt))          \
 	 {					    \
-		cout << "unable to lock" << endl;   \
+		std::cout << "unable to lock" << std::endl;   \
 		exit(1);			    \
 	 }
  #define UNLOCK					      \
 	 if (pthread_mutex_unlock(&lock_mt))	      \
 	 {					      \
-		cout << "unable to unlock" << endl;   \
+		std::cout << "unable to unlock" << std::endl;   \
 		exit(1);			      \
 	 }
 
--- iometer-1.1.0-rc1/src/IOTargetDisk.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOTargetDisk.cpp	Mon Aug 20 18:18:45 2012
@@ -239,7 +239,7 @@
 #endif
 
 	else {
-		cout << "*** Invalid disk type in TargetDisk::Initialize()." << endl;
+		std::cout << "*** Invalid disk type in TargetDisk::Initialize()." << std::endl;
 		retval = FALSE;
 	}
 
@@ -272,7 +272,7 @@
 		Set_Starting_Sector(spec.disk_info.starting_sector);
 #elif defined(IOMTR_CPU_XSCALE)
 		// TODO: Need to double check if this is correct for xscale
-		cout << spec.disk_info.starting_sector << endl;
+		std::cout << spec.disk_info.starting_sector << std::endl;
 		Set_Starting_Sector(spec.disk_info.starting_sector);
 #else
 #warning ===> WARNING: You have to do some coding here to get the port done!
@@ -496,8 +496,8 @@
 	if (new_size && (new_size < size)) {
 		size = new_size;
 #ifdef _DEBUG
-		cout << "Resetting accessible size of disk " << spec.name << " to " <<
-		    maximum_size << " sectors." << endl << "   " << spec.name << " size = " << size << endl;
+		std::cout << "Resetting accessible size of disk " << spec.name << " to " <<
+		    maximum_size << " sectors." << std::endl << "   " << spec.name << " size = " << size << std::endl;
 #endif
 	}
 }
@@ -513,7 +513,7 @@
 	starting_position = (DWORDLONG) starting_sector *(DWORDLONG) spec.disk_info.sector_size;
 
 #ifdef _DEBUG
-	cout << "Moving starting sector of disk " << spec.name << " to " << starting_position << "." << endl;
+	std::cout << "Moving starting sector of disk " << spec.name << " to " << starting_position << "." << std::endl;
 #endif
 
 	// Moving the starting disk sector may have shrunk the accessible size of the disk.
@@ -524,7 +524,7 @@
 		// Re-adjust the accessible size of the disk to reflect the new starting sector.
 		size -= starting_position;
 #ifdef _DEBUG
-		cout << "Starting sector size has shrunk the effective size of the disk." << endl;
+		std::cout << "Starting sector size has shrunk the effective size of the disk." << std::endl;
 #endif
 	} else {
 		// The new starting sector did not affect the accessible disk size.
@@ -553,8 +553,8 @@
 
 	if (open_disk) {
 		if (!Open(NULL)) {
-			cout << __FUNCTION__ << ": Open on \"" << file_name <<
-			    "\" failed (error " << strerror(errno) << ")." << endl;
+			std::cout << __FUNCTION__ << ": Open on \"" << file_name <<
+			    "\" failed (error " << strerror(errno) << ")." << std::endl;
 			return (FALSE);
 		}
 		fd = ((struct File *)disk_file)->fd;
@@ -573,7 +573,7 @@
 			statResult = statfs(filesysName, &fsInfo);
 		}
 		if (statResult < 0) {
-			cerr << __FUNCTION__ << ": Couldn't statfs logical disk file!" << endl;
+			std::cerr << __FUNCTION__ << ": Couldn't statfs logical disk file!" << std::endl;
 			if (open_disk) {
 				Close(NULL);
 			}
@@ -588,7 +588,7 @@
 			statResult = stat(file_name, &fileInfo);
 		}
 		if (statResult < 0) {
-			cerr << __FUNCTION__ << ": Error " << strerror(errno) << "statting file " << file_name << endl;
+			std::cerr << __FUNCTION__ << ": Error " << strerror(errno) << "statting file " << file_name << std::endl;
 			if (open_disk) {
 				Close(NULL);
 			}
@@ -612,7 +612,7 @@
 	} else {
 		spec.disk_info.sector_size = getSectorSizeOfPhysDisk(file_name);
 		if (spec.disk_info.sector_size == 0) {
-			cerr << __FUNCTION__ << ": Failed to get sector size for " << file_name << ". Skip it." << endl;
+			std::cerr << __FUNCTION__ << ": Failed to get sector size for " << file_name << ". Skip it." << std::endl;
 			if (open_disk) {
 				Close(NULL);
 			}
@@ -620,7 +620,7 @@
 		}
 		size = getSizeOfPhysDisk(file_name);
 		if (size == 0) {
-			cerr << __FUNCTION__ << ": Failed to get device size for " << file_name << ". Skip it." << endl;
+			std::cerr << __FUNCTION__ << ": Failed to get device size for " << file_name << ". Skip it." << std::endl;
 			if (open_disk)
 				Close(NULL);
 			return (FALSE);
@@ -654,8 +654,8 @@
 	if (open_disk) {
 		if (!Open(NULL)) {
 #ifdef _DEBUG
-			cout << __FUNCTION__ << ": Open on \"" << file_name <<
-			    "\" failed (error " << strerror(errno) << ")." << endl;
+			std::cout << __FUNCTION__ << ": Open on \"" << file_name <<
+			    "\" failed (error " << strerror(errno) << ")." << std::endl;
 #endif
 			return (FALSE);
 		}
@@ -678,7 +678,7 @@
 		netware_vol_info(&spaceInfo, (int *)&fsInfo.st_dev);
 
 		if (statResult < 0) {
-			cerr << __FUNCTION__ << ": Couldn't stat logical disk file!" << endl;
+			std::cerr << __FUNCTION__ << ": Couldn't stat logical disk file!" << std::endl;
 			if (open_disk)
 				Close(NULL);
 			return (FALSE);
@@ -692,7 +692,7 @@
 			statResult = stat(file_name, &fileInfo);
 		}
 		if (statResult < 0) {
-			cerr << __FUNCTION__ << ": Error " << strerror(errno) << " statting file " << file_name << endl;
+			std::cerr << __FUNCTION__ << ": Error " << strerror(errno) << " statting file " << file_name << std::endl;
 			if (open_disk) {
 				Close(NULL);
 			}
@@ -719,7 +719,7 @@
 		MM_ReturnObjectGenericInfo(atoi(file_name), sizeof(struct IOObjectGenericInfoDef), &info);
 		spec.disk_info.sector_size = info.unitsize;
 		if (spec.disk_info.sector_size == 0) {
-			cout << __FUNCTION__ << ": Failed to get sector size. Aborting target." << endl;
+			std::cout << __FUNCTION__ << ": Failed to get sector size. Aborting target." << std::endl;
 			return (FALSE);
 		}
 		size = info.capacity;
@@ -733,7 +733,7 @@
 			Close(NULL);
 		return (TRUE);
 	} else {
-		cout << "*** Unexpected drive type in Disk::SetSizes()" << endl << flush;
+		std::cout << "*** Unexpected drive type in Disk::SetSizes()" << std::endl << std::flush;
 		if (open_disk)
 			Close(NULL);
 		return (FALSE);
@@ -762,7 +762,7 @@
 	if (IsType(spec.type, LogicalDiskType)) {
 		// Getting physical information about the drive. All we need is the sector size. !!!!
 		if (statvfs(file_name, &st) < 0) {
-			cout << "statvfs error " << errno << ". Cannot get sector size" << endl;
+			std::cout << "statvfs error " << errno << ". Cannot get sector size" << std::endl;
 			if (open_disk)
 				Close(NULL);
 			return (FALSE);
@@ -776,7 +776,7 @@
 		struct stat64 stbuf64;
 
 		if (stat64(file_name, &stbuf64) < 0) {
-			cout << "unable to get file size. stat64() failed with error " << errno << endl;
+			std::cout << "unable to get file size. stat64() failed with error " << errno << std::endl;
 			if (open_disk)
 				Close(NULL);
 			return (FALSE);
@@ -785,7 +785,7 @@
 
 		Set_Sector_Info();
 #ifdef _DEBUG
-		cout << "   " << spec.name << " size = " << size << endl << flush;
+		std::cout << "   " << spec.name << " size = " << size << std::endl << std::flush;
 #endif
 		if (open_disk)
 			Close(NULL);
@@ -821,7 +821,7 @@
 				// We are dealing with a slice
 				size = Get_Slice_Size(part_name, part);
 #ifdef _DEBUG
-				cout << " slice size : " << size << endl;
+				std::cout << " slice size : " << size << std::endl;
 #endif
 				if (size <= 0) {
 					if (open_disk)
@@ -834,7 +834,7 @@
 				// We are dealing with an fdisk partition.
 				size = Get_Partition_Size(part_name, part);
 #ifdef _DEBUG
-				cout << " partn size : " << size << endl;
+				std::cout << " partn size : " << size << std::endl;
 #endif
 				if (size <= 0) {
 					if (open_disk)
@@ -844,8 +844,8 @@
 			}
 #endif				// __i386 || _IA64 || _PPC
 #ifdef _DEBUG
-			cout << "spec name : " << spec.name
-			    << " part_name : " << part_name << " part : " << part << endl;
+			std::cout << "spec name : " << spec.name
+			    << " part_name : " << part_name << " part : " << part << std::endl;
 #endif
 		} else {
 			// Getting information on the size of the drive.
@@ -878,7 +878,7 @@
 		Set_Sector_Info();
 
 #ifdef _DEBUG
-		cout << "   " << spec.name << " size = " << size << endl << flush;
+		std::cout << "   " << spec.name << " size = " << size << std::endl << std::flush;
 #endif
 
 		if (open_disk)
@@ -888,7 +888,7 @@
 		spec.disk_info.ready = TRUE;
 		return (TRUE);
 	} else {
-		cout << "*** Unexpected drive type in Disk::SetSizes()" << endl << flush;
+		std::cout << "*** Unexpected drive type in Disk::SetSizes()" << std::endl << std::flush;
 		if (open_disk)
 			Close(NULL);
 		return (FALSE);
@@ -916,7 +916,7 @@
 
 		// Getting physical information about the drive.
 		if (!GetDiskFreeSpace(temp_name, &sectors_per_cluster, &sector_size, &free_clusters, &total_clusters)) {
-			cout << "Error getting sector size of drive " << spec.name << "." << endl;
+			std::cout << "Error getting sector size of drive " << spec.name << "." << std::endl;
 			if (open_disk)
 				Close(NULL);
 			return FALSE;
@@ -928,7 +928,7 @@
 		size = (((DWORDLONG) high_size) << 32) | (DWORDLONG) low_size;
 		Set_Sector_Info();
 #ifdef _DEBUG
-		cout << "   " << spec.name << " size = " << size << endl;
+		std::cout << "   " << spec.name << " size = " << size << std::endl;
 #endif
 		if (open_disk)
 			Close(NULL);
@@ -976,7 +976,7 @@
 #else					
 					if ( open_disk )
 						Close( NULL );				
-					cout << "Physical disk \'" << spec.name << "\' contains partition information." << endl;
+					std::cout << "Physical disk \'" << spec.name << "\' contains partition information." << std::endl;
 					return FALSE;
 #endif
 				}
@@ -997,7 +997,7 @@
 #else					
 					if ( open_disk )
 						Close( NULL );				
-					cout << "Physical disk \'" << spec.name << "\' contains partition information." << endl;
+					std::cout << "Physical disk \'" << spec.name << "\' contains partition information." << std::endl;
 					return FALSE;
 #endif
 				}
@@ -1004,8 +1004,8 @@
 			}
 		}
 		else {
-			cout << "TargetDisk::Set_Sizes() Failed getting drive layout info, error " 
-				 << GetLastError() << "." << endl;
+			std::cout << "TargetDisk::Set_Sizes() Failed getting drive layout info, error " 
+				 << GetLastError() << "." << std::endl;
 			return FALSE;
 		}
 
@@ -1032,8 +1032,8 @@
 		}
 		else {
 			// print some warning and return error
-			cout << "TargetDisk::Set_Sizes() Failed getting drive geometry, error " 
-				 << GetLastError() << "." << endl;
+			std::cout << "TargetDisk::Set_Sizes() Failed getting drive geometry, error " 
+				 << GetLastError() << "." << std::endl;
 			return FALSE;
 		}
 
@@ -1040,7 +1040,7 @@
 		Set_Sector_Info();
 
 #ifdef _DEBUG
-		cout << "   " << spec.name << " size = " << size << endl;
+		std::cout << "   " << spec.name << " size = " << size << std::endl;
 #endif
 
 		if (open_disk)
@@ -1049,7 +1049,7 @@
 		spec.disk_info.ready = TRUE;
 		return TRUE;
 	} else {
-		cout << "*** Unexpected drive type in TargetDisk::SetSizes()" << endl;
+		std::cout << "*** Unexpected drive type in TargetDisk::SetSizes()" << std::endl;
 		return FALSE;
 	}
 }
@@ -1066,7 +1066,7 @@
 
 	if (IsType(spec.type, LogicalDiskType)) {
 		if (statfs(file_name, &st) < 0) {
-			cout << "statfs error " << errno << ". Cannot get sector size" << endl;
+			std::cout << "statfs error " << errno << ". Cannot get sector size" << std::endl;
 			if (open_disk)
 				Close(NULL);
 			return (FALSE);
@@ -1077,7 +1077,7 @@
 		struct stat stbuf64;
 
 		if (stat(file_name, &stbuf64) < 0) {
-			cout << "unable to get file size. stat failed with error " << errno << endl;
+			std::cout << "unable to get file size. stat failed with error " << errno << std::endl;
 			if (open_disk)
 				Close(NULL);
 			return (FALSE);
@@ -1086,7 +1086,7 @@
 
 		Set_Sector_Info();
 #ifdef _DEBUG
-		cout << "    " << spec.name << " size = " << size << endl << flush;
+		std::cout << "    " << spec.name << " size = " << size << std::endl << std::flush;
 #endif
 		if (open_disk)
 			Close(NULL);
@@ -1119,7 +1119,7 @@
 		Set_Sector_Info();
 
 #ifdef _DEBUG
-		cout << "    " << spec.name << " size = " << size << endl << flush;
+		std::cout << "    " << spec.name << " size = " << size << std::endl << std::flush;
 #endif
 
 		if (open_disk)
@@ -1129,7 +1129,7 @@
 		spec.disk_info.ready = TRUE;
 		return (TRUE);
 	} else {
-		cout << "*** Unexpected drive type in Disk::SetSizes()" << endl << flush;
+		std::cout << "*** Unexpected drive type in Disk::SetSizes()" << std::endl << std::flush;
 		if (open_disk)
 			Close(NULL);
 		return (FALSE);
@@ -1216,7 +1216,7 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
-		cout << "*** Could not allocate buffer to prepare disk." << endl;
+		std::cout << "*** Could not allocate buffer to prepare disk." << std::endl;
 		return FALSE;
 	}
 
@@ -1234,7 +1234,7 @@
 	}
 
 #ifdef _DEBUG
-	cout << "into function TargetDisk::Prepare()" << endl;
+	std::cout << "into function TargetDisk::Prepare()" << std::endl;
 #endif
 
 	write_ok = TRUE;
@@ -1256,7 +1256,7 @@
 
 		// Was the event created successfully?
 		if (olap[i].hEvent == NULL) {
-			cerr << "*** CreateEvent() failed in TargetDisk::Prepare()" << endl;
+			std::cerr << "*** CreateEvent() failed in TargetDisk::Prepare()" << std::endl;
 			write_ok = FALSE;	// don't perform any I/O
 			retval = FALSE;	// return failure status
 			break;	// break out of initialization loop
@@ -1298,7 +1298,7 @@
 					// A maximum disk size was specified by the user, and the next write 
 					// would go past the specified maximum size.  
 #ifdef _DEBUG
-					cout << "User-specified maximum size reached!" << endl;
+					std::cout << "User-specified maximum size reached!" << std::endl;
 #endif
 					// Stop writing and break out of the write loop.
 					write_ok = FALSE;
@@ -1337,8 +1337,8 @@
 					if (WriteFile(disk_file, (char *)buffer, bytes, &bytes_written, &(olap[i]))) {
 						// It succeeded immediately!
 #ifdef _DEBUG
-						cout << "Wrote (immediately) " << bytes_written << " of "
-						    << bytes << " bytes to disk " << spec.name << "." << endl;
+						std::cout << "Wrote (immediately) " << bytes_written << " of "
+						    << bytes << " bytes to disk " << spec.name << "." << std::endl;
 #endif
 						// Advance the file pointer, but do not mark the slot as busy.
 						*prepare_offset += bytes;
@@ -1347,9 +1347,9 @@
 						if (GetLastError() == ERROR_IO_PENDING) {
 							// It started OK.
 #if _DETAILS
-							cout << "I/O started successfully for slot #" << i
+							std::cout << "I/O started successfully for slot #" << i
 							    << " for " << bytes << " bytes at address "
-							    << *prepare_offset << endl;
+							    << *prepare_offset << std::endl;
 #endif
 							// Advance the file pointer and mark the slot as busy.
 							*prepare_offset += bytes;
@@ -1358,9 +1358,9 @@
 						} else if (GetLastError() == ERROR_DISK_FULL) {
 							// The disk filled up -- this is an expected error.
 #ifdef _DEBUG
-							cout << "Disk full (immediately) while writing "
+							std::cout << "Disk full (immediately) while writing "
 							    << bytes_written << " of " << bytes << " bytes to disk "
-							    << spec.name << "." << endl;
+							    << spec.name << "." << std::endl;
 #endif
 							// Stop writing and break out of the write loop.
 							write_ok = FALSE;
@@ -1367,9 +1367,9 @@
 							break;
 						} else {
 							// It didn't start OK!  Bail out.
-							cout << "***Error (immediately) writing " << bytes_written <<
+							std::cout << "***Error (immediately) writing " << bytes_written <<
 							    " of " << bytes << " bytes to disk " << spec.name <<
-							    ", error=" << GetLastError() << endl;
+							    ", error=" << GetLastError() << std::endl;
 							write_ok = FALSE;	// don't perform any more I/O
 							retval = FALSE;	// return failure status
 							break;	// break out of write loop
@@ -1388,8 +1388,8 @@
 					if (GetOverlappedResult(disk_file, &(olap[i]), &bytes_written, FALSE)) {
 						// It completed successfully!
 #ifdef _DEBUG
-						cout << "Wrote (eventually) " << bytes_written << " of " << bytes
-						    << " bytes to disk " << spec.name << "." << endl;
+						std::cout << "Wrote (eventually) " << bytes_written << " of " << bytes
+						    << " bytes to disk " << spec.name << "." << std::endl;
 #endif
 						// Mark the slot as idle.
 						busy[i] = FALSE;
@@ -1396,8 +1396,8 @@
 						num_outstanding--;
 
 						if (bytes_written != bytes) {
-							cout << "***Error (eventually); wrote only " << bytes_written
-							    << " of " << bytes << " bytes!" << endl;
+							std::cout << "***Error (eventually); wrote only " << bytes_written
+							    << " of " << bytes << " bytes!" << std::endl;
 							retval = FALSE;
 							write_ok = FALSE;
 							break;
@@ -1405,14 +1405,14 @@
 					} else if (GetLastError() == ERROR_IO_INCOMPLETE) {
 						// The I/O has not yet completed -- this is an expected error.
 #if _DETAILS
-						cout << "I/O not yet complete for slot #" << i << endl;
+						std::cout << "I/O not yet complete for slot #" << i << std::endl;
 #endif
 						;	// Do nothing.
 					} else if (GetLastError() == ERROR_DISK_FULL) {
 						// The disk filled up -- this is an expected error.
 #ifdef _DEBUG
-						cout << "Disk full (eventually) while writing " << bytes_written <<
-						    " of " << bytes << " bytes to disk " << spec.name << "." << endl;
+						std::cout << "Disk full (eventually) while writing " << bytes_written <<
+						    " of " << bytes << " bytes to disk " << spec.name << "." << std::endl;
 #endif
 						// Since the write did not actually succeed, decrement the file pointer.
 						*prepare_offset -= bytes;
@@ -1422,9 +1422,9 @@
 						num_outstanding--;
 					} else {
 						// The I/O failed!  Bail out.
-						cout << "***Error (eventually) writing " << bytes_written << " of " <<
+						std::cout << "***Error (eventually) writing " << bytes_written << " of " <<
 						    bytes << " bytes to disk " << spec.
-						    name << ", error=" << GetLastError() << endl;
+						    name << ", error=" << GetLastError() << std::endl;
 						// Stop writing and mark the slot as idle.
 						write_ok = FALSE;
 						busy[i] = FALSE;
@@ -1455,13 +1455,13 @@
 	// This allows the PRNG to be the same when doing the actual IO, whether the disk is prepped or not and the user specifies fixed seed
 	if(spec.use_fixed_seed)
 	{
-		cout << "   Resetting Targets random seed back to(" << rand_seed << ") after disk preperation." << endl;
+		std::cout << "   Resetting Targets random seed back to(" << rand_seed << ") after disk preperation." << std::endl;
 		spec.random = rand_seed;
 	}
 		
 
 #ifdef _DEBUG
-	cout << "out of member function TargetDisk::Prepare()" << endl;
+	std::cout << "out of member function TargetDisk::Prepare()" << std::endl;
 #endif
 
 	return retval;
@@ -1511,12 +1511,12 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	} else {
-		cout << "*** Unexpected drive type in TargetDisk::Open()" << endl;
+		std::cout << "*** Unexpected drive type in TargetDisk::Open()" << std::endl;
 	}
 
 	offset = starting_position;
 #if _DISK_MSGS
-	cout << "Opening disk " << spec.name << endl;
+	std::cout << "Opening disk " << spec.name << std::endl;
 #endif
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	if (disk_file == INVALID_HANDLE_VALUE)
@@ -1555,13 +1555,13 @@
 #endif
 	{
 #if _DISK_MSGS
-		cout << "Disk is already closed." << endl;
+		std::cout << "Disk is already closed." << std::endl;
 #endif
 		return TRUE;
 	}
 
 #if _DISK_MSGS
-	cout << "Closing disk " << spec.name << endl;
+	std::cout << "Closing disk " << spec.name << std::endl;
 #endif
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
@@ -1572,8 +1572,8 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
-		cout << "*** Error " << GetLastError()
-		    << " closing disk in TargetDisk::Close()." << endl;
+		std::cout << "*** Error " << GetLastError()
+		    << " closing disk in TargetDisk::Close()." << std::endl;
 		SetLastError(0);
 		return FALSE;
 	}
@@ -1636,7 +1636,7 @@
 				// If we went beyond the end of the disk again, report an error.
 #ifdef _DEBUG
 				if ((offset + (DWORDLONG) request_size) > ending_position) {
-					cout << "*** Can't align on " << user_alignment << " byte boundaries" << endl;
+					std::cout << "*** Can't align on " << user_alignment << " byte boundaries" << std::endl;
 
 					offset = starting_position;
 				}
@@ -1667,8 +1667,8 @@
 					// If we went beyond the end of the disk again, report an error.
 #ifdef _DEBUG
 					if ((offset + (DWORDLONG) request_size) > ending_position) {
-						cout << "*** Can't align on " << spec.disk_info.sector_size
-						    << " byte boundaries" << endl;
+						std::cout << "*** Can't align on " << spec.disk_info.sector_size
+						    << " byte boundaries" << std::endl;
 
 						offset = starting_position;
 					}
@@ -1681,8 +1681,8 @@
 					// If we went beyond the end of the disk again, report an error.
 #ifdef _DEBUG
 					if ((offset + (DWORDLONG) request_size) > ending_position) {
-						cout << "*** ERROR: Can't align on " << spec.disk_info.sector_size
-						    << " byte boundaries" << endl;
+						std::cout << "*** ERROR: Can't align on " << spec.disk_info.sector_size
+						    << " byte boundaries" << std::endl;
 
 						offset = starting_position;
 					}
@@ -1708,7 +1708,7 @@
 				// If we went beyond the end of the disk again, report an error.
 #ifdef _DEBUG
 				if ((offset + (DWORDLONG) request_size) > ending_position) {
-					cout << "*** Can't align on " << alignment << " byte boundaries" << endl;
+					std::cout << "*** Can't align on " << alignment << " byte boundaries" << std::endl;
 
 					offset = starting_position;
 				}
@@ -1732,18 +1732,18 @@
 	// Checking for the access to be a multiple of the sector size.
 	// Avoiding this check during actual testing for performance reasons.
 	if (offset % spec.disk_info.sector_size) {
-		cout << "Invalid offset.  Not aligned with disk sector size for : " << spec.name << endl;
+		std::cout << "Invalid offset.  Not aligned with disk sector size for : " << spec.name << std::endl;
 		return (ReturnError);
 	}
 	if (trans->size % spec.disk_info.sector_size) {
-		cout << "Invalid transfer size.  Not aligned with disk sector size for : " << spec.name << endl;
+		std::cout << "Invalid transfer size.  Not aligned with disk sector size for : " << spec.name << std::endl;
 		return (ReturnError);
 	}
 #endif
 
 #if _DETAILS
-	cout << "Reading " << trans->size << " bytes from disk : "
-	    << spec.name << endl << "   Accessing : " << offset << endl;
+	std::cout << "Reading " << trans->size << " bytes from disk : "
+	    << spec.name << std::endl << "   Accessing : " << offset << std::endl;
 #endif
 
 	// Determining location of read to disk.
@@ -1773,8 +1773,8 @@
 		bytes_transferred = 0;
 
 		// Return error.
-		cout << "*** Error " << error_no << " reading " << trans->size
-		    << " bytes from disk " << spec.name << "." << endl;
+		std::cout << "*** Error " << error_no << " reading " << trans->size
+		    << " bytes from disk " << spec.name << "." << std::endl;
 		return ReturnError;
 	}
 	// An asynchronous read was successfully initiated!
@@ -1784,7 +1784,7 @@
 	bytes_transferred = trans->size;
 
 #if _DETAILS
-	cout << "Queued read for " << trans->size << " bytes from disk " << spec.name << "." << endl;
+	std::cout << "Queued read for " << trans->size << " bytes from disk " << spec.name << "." << std::endl;
 #endif
 	return ReturnPending;
 }
@@ -1802,18 +1802,18 @@
 	// Verifying that the amount to be written is a multiple of the sector size.
 	// Avoiding this check during actual testing for performance reasons.
 	if (offset % spec.disk_info.sector_size) {
-		cout << "Invalid offset.  Not aligned with disk sector size for : " << spec.name << endl;
+		std::cout << "Invalid offset.  Not aligned with disk sector size for : " << spec.name << std::endl;
 		return (ReturnError);
 	}
 	if (trans->size % spec.disk_info.sector_size) {
-		cout << "Invalid transfer size.  Not aligned with disk sector size for : " << spec.name << endl;
+		std::cout << "Invalid transfer size.  Not aligned with disk sector size for : " << spec.name << std::endl;
 		return (ReturnError);
 	}
 #endif
 
 #if _DETAILS
-	cout << "Writing " << trans->size << " bytes to disk : " << spec.name
-	    << endl << "   Accessing : " << offset << endl;
+	std::cout << "Writing " << trans->size << " bytes to disk : " << spec.name
+	    << std::endl << "   Accessing : " << offset << std::endl;
 #endif
 
 	// Determining location of write to disk.
@@ -1843,8 +1843,8 @@
 		bytes_transferred = 0;
 
 		// Return error code.
-		cout << "*** Error " << error_no << " writing " << trans->size
-		    << " bytes to disk " << spec.name << "." << endl;
+		std::cout << "*** Error " << error_no << " writing " << trans->size
+		    << " bytes to disk " << spec.name << "." << std::endl;
 		return ReturnError;
 	}
 	// An asynchronous write was successfully initiated!  
@@ -1854,7 +1854,7 @@
 	bytes_transferred = trans->size;
 
 #if _DETAILS
-	cout << "Queued write for " << trans->size << " bytes to disk " << spec.name << "." << endl;
+	std::cout << "Queued write for " << trans->size << " bytes to disk " << spec.name << "." << std::endl;
 #endif
 	return ReturnPending;
 }
@@ -1971,7 +1971,7 @@
 		fullDevName = devNameBuf;
 	}
 	if ((fd = open(fullDevName, O_RDWR)) < 0) {
-		cerr << "Fail to open device" << endl;
+		std::cerr << "Fail to open device" << std::endl;
 		return 0;
 	}
 
@@ -1985,7 +1985,7 @@
 	// BLKBSZGET which returns the (potential) file system cluster size.
 
 	if (ioctl(fd, BLKSSZGET, &ssz) < 0) {
-		cerr << "Fail to get sector size for " << fullDevName << endl;
+		std::cerr << "Fail to get sector size for " << fullDevName << std::endl;
 		close(fd);
 		return 0;
 	}
@@ -2016,18 +2016,18 @@
 		fullDevName = devNameBuf;
 	}
 	if ((fd = open(fullDevName, O_RDWR)) < 0) {
-		cerr << "Fail to open device" << endl;
+		std::cerr << "Fail to open device" << std::endl;
 		return 0;
 	}
 	if (ioctl(fd, BLKGETSIZE64, &sz64) < 0) {
-		//cerr << "Fail to get size for " << fullDevName << " by BLKGETSIZE64" << endl;
-		cerr << "Warning: Reading the device geometry for " << fullDevName << " failed using the ";
-		cerr << "primary detection method - going to try backup method (this puts a 2TB limit ";
-		cerr << "on Iometer for accessing the device)" << endl;
+		//std::cerr << "Fail to get size for " << fullDevName << " by BLKGETSIZE64" << std::endl;
+		std::cerr << "Warning: Reading the device geometry for " << fullDevName << " failed using the ";
+		std::cerr << "primary detection method - going to try backup method (this puts a 2TB limit ";
+		std::cerr << "on Iometer for accessing the device)" << std::endl;
 		if (ioctl(fd, BLKGETSIZE, &sz32) < 0) {
-			//cerr << "Fail to get size for " << fullDevName << "by BLKGETSIZE" << endl;
-			cerr << "ERROR: Reading the device geometry for " << fullDevName << " failed using ";
-			cerr << "the backup detection method - give up (device will not be usable by Iometer)" << endl;
+			//std::cerr << "Fail to get size for " << fullDevName << "by BLKGETSIZE" << std::endl;
+			std::cerr << "ERROR: Reading the device geometry for " << fullDevName << " failed using ";
+			std::cerr << "the backup detection method - give up (device will not be usable by Iometer)" << std::endl;
 			sz64 = 0;
 		} else {
 			sz64 = sz32;
@@ -2035,7 +2035,7 @@
 		}
 	}
 #ifdef _DEBUG
-	cout << "Device " << fullDevName << " size:" << sz64 << "Bytes." << endl;
+	std::cout << "Device " << fullDevName << " size:" << sz64 << "Bytes." << std::endl;
 #endif
 
 	close(fd);
--- iometer-1.1.0-rc1/src/VINic.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/VINic.cpp	Mon Aug 20 18:18:45 2012
@@ -78,26 +78,26 @@
 	VIP_RETURN result;
 
 #if VINIC_DETAILS
-	cout << "Opening VI NIC " << nic_name << "." << endl;
+	std::cout << "Opening VI NIC " << nic_name << "." << std::endl;
 #endif
 
 	// Open the NIC.
 	if ((result = vipl.VipOpenNic((const VIP_CHAR *)nic_name, &nic)) != VIP_SUCCESS) {
 #ifdef _DEBUG
-		cout << "Unable to open VI nic " << nic_name << ": " << vipl.Error(result) << endl;
+		std::cout << "Unable to open VI nic " << nic_name << ": " << vipl.Error(result) << std::endl;
 #endif
 		return FALSE;
 	}
 	// Record the NIC attributes.
 	if ((result = vipl.VipQueryNic(nic, &nic_attributes)) != VIP_SUCCESS) {
-		cout << "*** Unable to record attributes for VI nic " << nic_name << ": " << vipl.Error(result) << endl;
+		std::cout << "*** Unable to record attributes for VI nic " << nic_name << ": " << vipl.Error(result) << std::endl;
 		vipl.VipCloseNic(nic);
 		return FALSE;
 	}
 	// Create the memory protection tag.
 	if ((result = vipl.VipCreatePtag(nic, &nic_mem_attributes.Ptag)) != VIP_SUCCESS) {
-		cout << "*** Unable to create protection tag for VI nic "
-		    << nic_name << ": " << vipl.Error(result) << endl;
+		std::cout << "*** Unable to create protection tag for VI nic "
+		    << nic_name << ": " << vipl.Error(result) << std::endl;
 		vipl.VipCloseNic(nic);
 		return FALSE;
 	}
@@ -122,7 +122,7 @@
 	BOOL result = TRUE;
 
 #if VINIC_DETAILS
-	cout << "Closing VI NIC " << nic_attributes.Name << "." << endl;
+	std::cout << "Closing VI NIC " << nic_attributes.Name << "." << std::endl;
 #endif
 
 	// Destroy the Ptag.
@@ -142,7 +142,7 @@
 BOOL VINic::GetLocalAddress()
 {
 #if VINIC_DETAILS
-	cout << "Retrieving the address for " << nic_attributes.Name << endl;
+	std::cout << "Retrieving the address for " << nic_attributes.Name << std::endl;
 #endif
 
 	// Allocate memory for the address.  A VI network address consists of:
@@ -150,7 +150,7 @@
 	nic_address_length = sizeof(VIP_NET_ADDRESS) + nic_attributes.NicAddressLen +
 	    nic_attributes.MaxDiscriminatorLen;
 	if (!(nic_address = (VIP_NET_ADDRESS *) malloc(nic_address_length))) {
-		cout << "*** Unable to allocate memory for VI NIC addresss." << endl;
+		std::cout << "*** Unable to allocate memory for VI NIC addresss." << std::endl;
 		return FALSE;
 	}
 	// Fill in the address.  Initialize the descriptor to 0.
@@ -169,7 +169,7 @@
 BOOL VINic::RegisterMemory(void *buffer, DWORD size, VIP_MEM_HANDLE * mem)
 {
 #if VINIC_DETAILS
-	cout << "Registering memory for nic " << nic_attributes.Name << endl;
+	std::cout << "Registering memory for nic " << nic_attributes.Name << std::endl;
 #endif
 
 	// Register the memory with the VI NIC.
@@ -184,7 +184,7 @@
 BOOL VINic::DeregisterMemory(void *buffer, VIP_MEM_HANDLE mem)
 {
 #if VINIC_DETAILS
-	cout << "Deregistering memory for nic " << nic_attributes.Name << endl;
+	std::cout << "Deregistering memory for nic " << nic_attributes.Name << std::endl;
 #endif
 
 	return (vipl.VipDeregisterMem(nic, buffer, mem) == VIP_SUCCESS);
--- iometer-1.1.0-rc1/src/Pulsar.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/Pulsar.cpp	Mon Aug 20 18:18:46 2012
@@ -184,8 +184,8 @@
 	res = open("/dev/iomtr_kstat", O_RDONLY);
 	if (res < 0) {
 #if defined(IOMTR_CPU_XSCALE)
-		cerr << "Failed to open kstat device file. You can ignore this warning" << endl;
-		cerr << "unless you are running dynamo on XSCALE CPU." << endl;
+		std::cerr << "Failed to open kstat device file. You can ignore this warning" << std::endl;
+		std::cerr << "unless you are running dynamo on XSCALE CPU." << std::endl;
 #endif
 	}
 	return res;
@@ -211,9 +211,9 @@
 
 	res = open("/dev/ccnt", O_RDONLY);
 	if (res < 0) {
-		cerr << "Fail to find CCNT interface." << endl;
-		cerr << "Please compile your kernel with CCNT (cycle counter) support" << endl;
-		cerr << "   and create corresponding /dev/ccnt node by ccntmknod script." << endl;
+		std::cerr << "Fail to find CCNT interface." << std::endl;
+		std::cerr << "Please compile your kernel with CCNT (cycle counter) support" << std::endl;
+		std::cerr << "   and create corresponding /dev/ccnt node by ccntmknod script." << std::endl;
 	}
 	return res;
 }
@@ -279,14 +279,14 @@
 	 * please try "sched_setaffinity(getpid(), &s)" instead.
 	 */
 	if (sched_setaffinity(getpid(), CPU_SETSIZE, &s) < 0) {
-		cout << "Set CPU affinity fail." << errno << endl;
+		std::cout << "Set CPU affinity fail." << errno << std::endl;
 		if (errno == ENOSYS) {
-			cout << "Warning: System does not support set CPU affinity." << endl;
-			cout << "Be sure to check if measured results are reasonable." << endl;
+			std::cout << "Warning: System does not support set CPU affinity." << std::endl;
+			std::cout << "Be sure to check if measured results are reasonable." << std::endl;
 		}
 	} else {
 #ifdef _DEBUG
-		cout << "Set CPU affinity sucessfully." << endl;
+		std::cout << "Set CPU affinity sucessfully." << std::endl;
 #endif
 	}
 
@@ -303,8 +303,8 @@
 	if (!res) 
 	{
 		res = GetLastError();
-		cout << "Could not obtain process affinity. GetProcessAffinityMask() failed with error=" 
-			 << GetLastError() << endl;
+		std::cout << "Could not obtain process affinity. GetProcessAffinityMask() failed with error=" 
+			 << GetLastError() << std::endl;
 		
 		return 0;
 	}
@@ -317,19 +317,19 @@
 		if (!res) 
 		{
 			res = GetLastError();
-			cout << "Set cpu affinity failed with error=" << GetLastError() << endl;
+			std::cout << "Set cpu affinity failed with error=" << GetLastError() << std::endl;
 			return 0;
 		}
 		else 
 		{
 #ifdef _DEBUG
-			cout << "Set CPU affinity sucessfully." << endl;
+			std::cout << "Set CPU affinity sucessfully." << std::endl;
 #endif
 		}
 	}
 	else
 	{
-		cout << "Warning: ignoring affinity mask due to redundant or invalid value." << endl;
+		std::cout << "Warning: ignoring affinity mask due to redundant or invalid value." << std::endl;
 	}
 
 #elif defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_SOLARIS)
@@ -452,22 +452,22 @@
 
 	// If there were command line parameters, indicate that they were recognized.
 	if (iometer[0] || manager->manager_name[0]) {
-		cout << "\nCommand line parameter(s):" << endl;
+		std::cout << "\nCommand line parameter(s):" << std::endl;
 
 		if (iometer[0]) {
-			cout << "   Looking for Iometer on \"" << iometer << "\"" << endl;
+			std::cout << "   Looking for Iometer on \"" << iometer << "\"" << std::endl;
 		}
 		if (manager->manager_name[0]) {
-			cout << "   New manager name is \"" << manager->manager_name << "\"" << endl;
+			std::cout << "   New manager name is \"" << manager->manager_name << "\"" << std::endl;
 		}
 	}
 	if (manager->exclude_filesys[0]) {
-		cout << "\nExcluding the following filesystem types:" << endl;
-		cout << "   \"" << manager->exclude_filesys << "\"" << endl;
+		std::cout << "\nExcluding the following filesystem types:" << std::endl;
+		std::cout << "   \"" << manager->exclude_filesys << "\"" << std::endl;
 	} else {
 		strcpy(manager->exclude_filesys, DEFAULT_EXCLUDE_FILESYS);
 	}
-	cout << endl;
+	std::cout << std::endl;
 
 #if defined(IOMTR_OSFAMILY_UNIX)
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX)
@@ -480,7 +480,7 @@
 
 	// Initialize the lock on UNIX platforms.
 	if (pthread_mutex_init(&lock_mt, NULL)) {
-		cout << "unable to init the lock" << endl;
+		std::cout << "unable to init the lock" << std::endl;
 		error = 1;
 		goto CleanUp;
 		//exit(1);
@@ -492,8 +492,8 @@
 	sigemptyset(&sigset);
 	sigaddset(&sigset, SIGPIPE);
 	if (sigprocmask(SIG_BLOCK, &sigset, NULL) < 0) {
-		cout << "sigprocmask() call failed." << endl;
-		cout << "dynamo could be unstable" << endl;
+		std::cout << "sigprocmask() call failed." << std::endl;
+		std::cout << "dynamo could be unstable" << std::endl;
 	}
 	//
 	// the number of file descriptors a process may create can be a small value like 64.
@@ -501,7 +501,7 @@
 	struct rlimit rlimitp;
 
 	if (getrlimit(RLIMIT_NOFILE, &rlimitp) < 0) {
-		cout << "error " << errno << " trying to get rlimit (# file descriptors)" << endl;
+		std::cout << "error " << errno << " trying to get rlimit (# file descriptors)" << std::endl;
 	} else {
 		// it succeeded. We leave out atleast 25 file descriptors for non-targets
 		// and compare with the hard limit.
@@ -508,7 +508,7 @@
 		unsigned int targets = MAX_TARGETS + 25;
 
 		if (rlimitp.rlim_max < targets) {
-			cout << "Only " << rlimitp.rlim_max << " file descriptors available" << endl;
+			std::cout << "Only " << rlimitp.rlim_max << " file descriptors available" << std::endl;
 			rlimitp.rlim_cur = rlimitp.rlim_max;
 		} else {
 			// set the soft limit to the required value.
@@ -515,7 +515,7 @@
 			rlimitp.rlim_cur = targets;
 		}
 		if (setrlimit(RLIMIT_NOFILE, &rlimitp) < 0) {
-			cout << "error " << errno << " trying to set rlimit (# file descriptors)" << endl;
+			std::cout << "error " << errno << " trying to set rlimit (# file descriptors)" << std::endl;
 		}
 	}
 
@@ -522,18 +522,18 @@
 	// Check for super-user permissions. If not super-user, we
 	// cannot get many of the info from the kernel.
 	if (getuid() || geteuid()) {
-		cout << "Dynamo not running as super-user." << endl;
-		cout << "       All available disks might not be reported " << endl;
-		cout << "       Cannot get TCP statistics from the kernel " << endl;
+		std::cout << "Dynamo not running as super-user." << std::endl;
+		std::cout << "       All available disks might not be reported " << std::endl;
+		std::cout << "       Cannot get TCP statistics from the kernel " << std::endl;
 	}
 #ifdef IOMTR_SETTING_OVERRIDE_FS
 	// No command line args specifies destructive testing. Check to see if there
 	// are any environment variables specifying the same. We need to warn the user.
 	if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL) {
-		cout << "       ************ WARNING **************" << endl;
-		cout << "       dynamo running in Destructive mode." << endl;
-		cout << "         (overriding the not mounted fs)" << endl;
-		cout << "       ************ WARNING **************" << endl;
+		std::cout << "       ************ WARNING **************" << std::endl;
+		std::cout << "       dynamo running in Destructive mode." << std::endl;
+		std::cout << "         (overriding the not mounted fs)" << std::endl;
+		std::cout << "       ************ WARNING **************" << std::endl;
 	}
 #endif				// IOMTR_SETTING_OVERRIDE_FS
 #endif				// IOMTR_OSFAMILY_UNIX
@@ -540,7 +540,7 @@
 #if defined(IOMTR_OSFAMILY_NETWARE)
 	// Initialize the lock on NetWare platforms.
 	if (pthread_mutex_init(&lock_mt, NULL)) {
-		cout << "unable to init the lock" << endl;
+		std::cout << "unable to init the lock" << std::endl;
 		error = 1;
 		goto CleanUp;
 		//exit(1);
@@ -570,10 +570,10 @@
 
 		if (!bReturned)
 		{
-			cout << "Dynamo not running as an administrators." << endl;
-			cout << "       All available disks might not be reported " << endl;
-			//cout << "       Cannot get TCP statistics from the kernel " << endl;
-			cout << endl;
+			std::cout << "Dynamo not running as an administrators." << std::endl;
+			std::cout << "       All available disks might not be reported " << std::endl;
+			//std::cout << "       Cannot get TCP statistics from the kernel " << std::endl;
+			std::cout << std::endl;
 		} 
 		FreeSid(AdminGroup); 
 	}
@@ -582,8 +582,8 @@
 
 	// Ensure, that the endian type of the CPU is detectable
 	if ((IsBigEndian() != 0) && (IsBigEndian() != 1)) {
-		cout << "===> ERROR: Endian type of the CPU couldn't be detected." << endl;
-		cout << "     [main() in " << __FILE__ << " line " << __LINE__ << "]" << endl;
+		std::cout << "===> ERROR: Endian type of the CPU couldn't be detected." << std::endl;
+		std::cout << "     [main() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl;
 		error = 1;
 		goto CleanUp;
 		//exit(1);
@@ -599,7 +599,7 @@
 		if (!manager->Run())
 			break;	// Stop running when the manager is done.
 	}
-	cout << "Ending execution." << endl;
+	std::cout << "Ending execution." << std::endl;
 	Sleep(1000);
 
 #if defined(IOMTR_OS_LINUX)
@@ -619,43 +619,43 @@
 
 void Banner()
 {
-	//cout << "Version " << g_pVersionStringWithDebug << endl;
-	cout << "Dynamo version " << IOVER_FILEVERSION << VERSION_DEBUG ; 
+	//std::cout << "Version " << g_pVersionStringWithDebug << std::endl;
+	std::cout << "Dynamo version " << IOVER_FILEVERSION << VERSION_DEBUG ; 
 
 #if (defined(IOMTR_OSFAMILY_WINDOWS) ||  defined(IOMTR_OS_LINUX))
   #if defined(IOMTR_CPU_I386)		//#if defined(_M_IX86)
-	cout << ", Intel x86 32bit";
+	std::cout << ", Intel x86 32bit";
   #elif defined(IOMTR_CPU_IA64)		//#elif defined(_M_IA64)
-	cout << ", Intel Itanium 64bit";
+	std::cout << ", Intel Itanium 64bit";
   #elif defined(IOMTR_CPU_X86_64)	//#elif defined(_M_X64)
-	cout << ", Intel/AMD x64 64bit";
+	std::cout << ", Intel/AMD x64 64bit";
  #endif
 
 #elif defined(IOMTR_OS_LINUX)
  #if defined(IOMTR_CPU_XSCALE) 
-	cout << ", Intel XScale";
+	std::cout << ", Intel XScale";
  #endif
 #elif defined(IOMTR_OS_OSX)
  #if defined(__ppc__)
-	cout << ", PowerPC 32bit";
+	std::cout << ", PowerPC 32bit";
  #elif defined(__ppc64__)
-	cout << ", PowerPC 64bit";
+	std::cout << ", PowerPC 64bit";
  #elif defined(__i386__)
-	cout << ", Intel x86 32bit";
+	std::cout << ", Intel x86 32bit";
  #elif defined(__x86_64__)
-	cout << ", Intel x86_64 64bit";
+	std::cout << ", Intel x86_64 64bit";
  #else
-	cout << ", unknown architecture and bitness";
+	std::cout << ", unknown architecture and bitness";
  #endif
   
  #if defined(__BIG__ENDIAN__)
-	cout << ", big-endian";
+	std::cout << ", big-endian";
  #endif
 #endif 
 
-	// cout << endl;
-	cout << ", built " << __DATE__ << " " << __TIME__ << endl;
-	cout << endl;
+	// std::cout << std::endl;
+	std::cout << ", built " << __DATE__ << " " << __TIME__ << std::endl;
+	std::cout << std::endl;
 }
 
 
@@ -668,93 +668,93 @@
 void Syntax(const char *errmsg /*=NULL*/ )
 {
 	if (errmsg) {
-		cout << endl << "*** Error processing the command line." << endl;
-		cout << "*** " << errmsg << endl;
+		std::cout << std::endl << "*** Error processing the command line." << std::endl;
+		std::cout << "*** " << errmsg << std::endl;
 	}
 
-	cout << endl;
+	std::cout << std::endl;
 
 	//Banner();
 
-	cout << "SYNTAX" << endl;
-	cout << endl;
+	std::cout << "SYNTAX" << std::endl;
+	std::cout << std::endl;
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX)
-	cout << "dynamo -?" << endl;
+	std::cout << "dynamo -?" << std::endl;
 #elif defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	cout << "dynamo /?" << endl;
+	std::cout << "dynamo /?" << std::endl;
 #elif defined(IOMTR_OS_SOLARIS)
 	// Solaris 2.7 must have the switch (? is used for its own purpose).
-	cout << "dynamo \\?" << endl;
+	std::cout << "dynamo \\?" << std::endl;
 #else
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
 #if defined(IOMTR_OS_LINUX)
-	cout << "dynamo [-i iometer_computer_name -m manager_computer_name] [-n manager_name]" << endl;
-	cout << "       [-x excluded_fs_type] [-d extra_device] [-f extra_device_file] [-l]" << endl;
-	cout << "       [-c cpu_affinity] [-p login_port_number]" << endl;
+	std::cout << "dynamo [-i iometer_computer_name -m manager_computer_name] [-n manager_name]" << std::endl;
+	std::cout << "       [-x excluded_fs_type] [-d extra_device] [-f extra_device_file] [-l]" << std::endl;
+	std::cout << "       [-c cpu_affinity] [-p login_port_number]" << std::endl;
 #elif defined (IOMTR_OS_SOLARIS)
-	cout << "dynamo [-i iometer_computer_name -m manager_computer_name] [-n manager_name]" << endl;
-	cout << "       [-x excluded_fs_type] [-d extra_device] [-f extra_device_file] [-l]" << endl;
-	cout << "       [-p login_port_number]" << endl;
+	std::cout << "dynamo [-i iometer_computer_name -m manager_computer_name] [-n manager_name]" << std::endl;
+	std::cout << "       [-x excluded_fs_type] [-d extra_device] [-f extra_device_file] [-l]" << std::endl;
+	std::cout << "       [-p login_port_number]" << std::endl;
 #elif defined(IOMTR_OS_OSX)
-	cout << "dynamo [-i iometer_computer_name -m manager_computer_name] [-n manager_name]" << endl;
-	cout << "       [-x excluded_fs_type] [-d extra_device] [-f extra_device_file] [-l]" << endl;
-	cout << "       [-p login_port_number]  [use_rdtsc]" << endl;
+	std::cout << "dynamo [-i iometer_computer_name -m manager_computer_name] [-n manager_name]" << std::endl;
+	std::cout << "       [-x excluded_fs_type] [-d extra_device] [-f extra_device_file] [-l]" << std::endl;
+	std::cout << "       [-p login_port_number]  [use_rdtsc]" << std::endl;
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	cout << "dynamo [/i iometer_computer_name /m manager_computer_name] [/n manager_name]" << endl;
-	cout << "       [/c cpu_affinity] [/p login_port_number]" << endl;
-	cout << "       [use_rdtsc] [force_raw] " << endl;
+	std::cout << "dynamo [/i iometer_computer_name /m manager_computer_name] [/n manager_name]" << std::endl;
+	std::cout << "       [/c cpu_affinity] [/p login_port_number]" << std::endl;
+	std::cout << "       [use_rdtsc] [force_raw] " << std::endl;
 #elif defined(IOMTR_OS_NETWARE)
-	cout << "dynamo [/i iometer_computer_name /m manager_computer_name] [/n manager_name]" << endl;
-	cout << "       [/x excluded_volumes] [/c cpu_affinity] [/p login_port_number]" << endl;
+	std::cout << "dynamo [/i iometer_computer_name /m manager_computer_name] [/n manager_name]" << std::endl;
+	std::cout << "       [/x excluded_volumes] [/c cpu_affinity] [/p login_port_number]" << std::endl;
 #else
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 
-	cout << endl;
-	cout << "   ? - show Dynamo version number and command line syntax" << endl;
-	cout << endl;
-	cout << "   iometer_computer_name - the name of the computer running Iometer" << endl;
-	cout << "      This is only needed if Dynamo and Iometer are running on different" << endl;
-	cout << "      computers.  Without this parameter, Dynamo will search for Iometer" << endl;
-	cout << "      on the local host." << endl;
-	cout << endl;
-	cout << "   manager_name - the name of this Dynamo" << endl;
-	cout << "      This name is the one Iometer will use as the manager name, important" << endl;
-	cout << "      when restoring config files.  This defaults to the host's name." << endl;
-	cout << endl;
-	cout << "   manager_computer_name - the name of the computer running this Dynamo" << endl;
-	cout << "      This name or IP address is the one Iometer will use to communicate" << endl;
-	cout << "      with this manager. The default is the IP adress of the host's first" << endl;
-	cout << "      NIC." << endl;
-	cout << "      Make sure iometer box can ping this name successfully, otherwise dynamo" << endl;
-	cout << "      and iometer will hang a long time during login." << endl;
-	cout << endl;
-	cout << "   login_port_number - the port number Iometer is listening on. If this" << endl;
-	cout << "      parameter is not given, the default port(" << WELL_KNOWN_TCP_PORT << ") will be used." << endl;
-	cout << endl;
+	std::cout << std::endl;
+	std::cout << "   ? - show Dynamo version number and command line syntax" << std::endl;
+	std::cout << std::endl;
+	std::cout << "   iometer_computer_name - the name of the computer running Iometer" << std::endl;
+	std::cout << "      This is only needed if Dynamo and Iometer are running on different" << std::endl;
+	std::cout << "      computers.  Without this parameter, Dynamo will search for Iometer" << std::endl;
+	std::cout << "      on the local host." << std::endl;
+	std::cout << std::endl;
+	std::cout << "   manager_name - the name of this Dynamo" << std::endl;
+	std::cout << "      This name is the one Iometer will use as the manager name, important" << std::endl;
+	std::cout << "      when restoring config files.  This defaults to the host's name." << std::endl;
+	std::cout << std::endl;
+	std::cout << "   manager_computer_name - the name of the computer running this Dynamo" << std::endl;
+	std::cout << "      This name or IP address is the one Iometer will use to communicate" << std::endl;
+	std::cout << "      with this manager. The default is the IP adress of the host's first" << std::endl;
+	std::cout << "      NIC." << std::endl;
+	std::cout << "      Make sure iometer box can ping this name successfully, otherwise dynamo" << std::endl;
+	std::cout << "      and iometer will hang a long time during login." << std::endl;
+	std::cout << std::endl;
+	std::cout << "   login_port_number - the port number Iometer is listening on. If this" << std::endl;
+	std::cout << "      parameter is not given, the default port(" << WELL_KNOWN_TCP_PORT << ") will be used." << std::endl;
+	std::cout << std::endl;
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	cout << "   excluded_fs_type - type of filesystems to exclude from device search" << endl;
-	cout << "      This string should contain the filesystem types that are not reported" << endl;
-	cout << "      to Iometer. The default is \"" << DEFAULT_EXCLUDE_FILESYS << "\"." << endl;
-	cout << endl;
-	cout << "   extra_device - block device name to be included in the test if this device" << endl;
-	cout << "      CAN NOT be detected automatically by dynamo. You can use it multiple times," << endl;
-	cout << "      for example, -b dev1 -b dev2 -b dev3..." << endl;
-	cout << endl;
-	cout << "   extra_device_file - a file store extra device names with each name in one line" << endl;
-	cout << "      use this in case you have lots of extra device need to be claimed." << endl;
-	cout << "      You MUST use absolute path for device name here." << endl;
-	cout << endl;
-	cout << "   -l - to record events in syslog, default is /var/log/messages." << endl;
-	cout << endl;
+	std::cout << "   excluded_fs_type - type of filesystems to exclude from device search" << std::endl;
+	std::cout << "      This string should contain the filesystem types that are not reported" << std::endl;
+	std::cout << "      to Iometer. The default is \"" << DEFAULT_EXCLUDE_FILESYS << "\"." << std::endl;
+	std::cout << std::endl;
+	std::cout << "   extra_device - block device name to be included in the test if this device" << std::endl;
+	std::cout << "      CAN NOT be detected automatically by dynamo. You can use it multiple times," << std::endl;
+	std::cout << "      for example, -b dev1 -b dev2 -b dev3..." << std::endl;
+	std::cout << std::endl;
+	std::cout << "   extra_device_file - a file store extra device names with each name in one line" << std::endl;
+	std::cout << "      use this in case you have lots of extra device need to be claimed." << std::endl;
+	std::cout << "      You MUST use absolute path for device name here." << std::endl;
+	std::cout << std::endl;
+	std::cout << "   -l - to record events in syslog, default is /var/log/messages." << std::endl;
+	std::cout << std::endl;
 #elif defined(IOMTR_OSFAMILY_NETWARE)
-	cout << "   excluded_volumes - volumes to exclude from volume or device search" << endl;
-	cout << "      The default is \"" << "none" << "\"." << endl;
-	cout << endl;
+	std::cout << "   excluded_volumes - volumes to exclude from volume or device search" << std::endl;
+	std::cout << "      The default is \"" << "none" << "\"." << std::endl;
+	std::cout << std::endl;
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	// nop  
 #else
@@ -762,24 +762,24 @@
 #endif
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
-	cout << "   cpu_affinity - cpu affinity is used to bind dynamo to certain processor(s)." << endl;
-	cout << "      This is used for getting a more consistent timing value. For example, if" << endl;
-	cout << "      you want to bind to the third cpu, you should have value 4(00000100) here." << endl;
-	cout << "      If this parameter is not specified, dynamo will bind to the first CPU" << endl;
-	cout << "      in system by default." << endl;
-	cout << endl;
+	std::cout << "   cpu_affinity - cpu affinity is used to bind dynamo to certain processor(s)." << std::endl;
+	std::cout << "      This is used for getting a more consistent timing value. For example, if" << std::endl;
+	std::cout << "      you want to bind to the third cpu, you should have value 4(00000100) here." << std::endl;
+	std::cout << "      If this parameter is not specified, dynamo will bind to the first CPU" << std::endl;
+	std::cout << "      in system by default." << std::endl;
+	std::cout << std::endl;
 #endif
 
 #if defined(IOMTR_OSFAMILY_WINDOWS) || defined(IOMTR_OS_OSX)
-	cout << "   use_rdtsc - enables explicit rdtsc use in favor of other OS API" << endl;
-	cout << "      for measuring I/O performance." << endl;
-	cout << endl;
+	std::cout << "   use_rdtsc - enables explicit rdtsc use in favor of other OS API" << std::endl;
+	std::cout << "      for measuring I/O performance." << std::endl;
+	std::cout << std::endl;
 #endif
 
 #if defined(IOMTR_OSFAMILY_WINDOWS)
-	cout << "   force_raw - forces dynamo to report all raw disks regardless of partitions" << endl;
-	cout << "      contained within them. " << endl;
-	cout << endl;
+	std::cout << "   force_raw - forces dynamo to report all raw disks regardless of partitions" << std::endl;
+	std::cout << "      contained within them. " << std::endl;
+	std::cout << std::endl;
 #endif
 
 	exit(0);
@@ -799,7 +799,7 @@
 	BOOL bParamIometer = FALSE;
 	BOOL bParamDynamo = FALSE;
 	int count = 0;
-	ifstream devfile;
+	std::ifstream devfile;
 
 	// Walk through the parameter list
 
@@ -845,7 +845,7 @@
 				if (param->timer_type != TIMER_UNDEFINED && param->timer_type < TIMER_TYPE_MAX)
 				{
 					TimerType = (timer_type) param->timer_type;
-					cout << "Dynamo will attempt to use the TSC/ITC CPU timer." << endl;
+					std::cout << "Dynamo will attempt to use the TSC/ITC CPU timer." << std::endl;
 				}
 
 				continue;
@@ -930,7 +930,7 @@
 			if (count < MAX_TARGETS) {
 				strcpy((*param->blkdevlist)[count++], argv[I]);
 			} else {
-				cout << "Too many targets you want to test, skip " << argv[I] << endl;
+				std::cout << "Too many targets you want to test, skip " << argv[I] << std::endl;
 			}
 			break;
 		case 'F':
@@ -949,7 +949,7 @@
 				if (count < MAX_TARGETS) {
 					strcpy((*param->blkdevlist)[count++], devname);
 				} else {
-					cout << "Too many targets you want to test, skip " << devname << endl;
+					std::cout << "Too many targets you want to test, skip " << devname << std::endl;
 				}
 			}
 			break;
No differences encountered
--- iometer-1.1.0-rc1/src/NetTCP.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/NetTCP.cpp	Mon Aug 20 18:18:46 2012
@@ -154,7 +154,7 @@
 	if ( InterlockedIncrement ( &sockets_in_use ) == 1 )
 	{
 		#if NETWORK_DETAILS || defined(_DEBUG)
-			cout << "Initializing WinSock." << endl;
+			std::cout << "Initializing WinSock." << std::endl;
 		#endif
 
 		// request WinSock version 2.0
@@ -163,7 +163,7 @@
 		if ( retval != 0 )
 		{
 			*errmsg << "*** Could not initialize WinSock!  Error " 
-				<< retval << ends;
+				<< retval << std::ends;
 			OutputErrMsg();
 			InterlockedDecrement ( &sockets_in_use );
 		}
@@ -182,7 +182,7 @@
 	if ( InterlockedDecrement ( &sockets_in_use ) == 0 )
 	{
 		#if NETWORK_DETAILS || defined(_DEBUG)
-			cout << "Cleaning up WinSock." << endl;
+			std::cout << "Cleaning up WinSock." << std::endl;
 		#endif
 		
 		// Reset the error code.
@@ -189,7 +189,7 @@
 		if ( WSACleanup() != 0 )
 		{
 			*errmsg << "*** Could not clean up WinSock!  Error " 
-				<< WSAGetLastError() << ends;
+				<< WSAGetLastError() << std::ends;
 			OutputErrMsg();
 		}
 	}
@@ -263,7 +263,7 @@
 ReturnVal NetAsyncTCP::CreateSocket( CONNECTION *s )
 {
 	#if NETWORK_DETAILS || _DETAILS
-		cout << "Creating socket." << endl;
+		std::cout << "Creating socket." << std::endl;
 	#endif
 
 	// Create socket.
@@ -275,7 +275,7 @@
 	if ( fp->fd < 0 )
 	{
 		*errmsg << "*** Could not create socket in NetAsyncTCP::"
-				<< "CreateSocket(), error: " << WSAGetLastError()  << ends;
+				<< "CreateSocket(), error: " << WSAGetLastError()  << std::ends;
 		OutputErrMsg();
 		fp->fd = (int) INVALID_SOCKET;
 		return ReturnError;
@@ -286,7 +286,7 @@
 	if ( *s == INVALID_SOCKET )
 	{
 		*errmsg << "*** Could not create socket in NetAsyncTCP::"
-				<< "CreateSocket(), error: " << WSAGetLastError()  << ends;
+				<< "CreateSocket(), error: " << WSAGetLastError()  << std::ends;
 		OutputErrMsg();
 		return ReturnError;
 	}
@@ -315,7 +315,7 @@
 #endif
 
 	#if NETWORK_DETAILS || _DETAILS
-		cout << "Binding to socket." << endl;
+		std::cout << "Binding to socket." << std::endl;
 	#endif
 
 	// Bind socket.
@@ -328,7 +328,7 @@
 #endif
 	{
 		*errmsg << "*** Error " << Error( WSAGetLastError() )
-				<< " binding to socket in NetAsyncTCP::BindSocket()." << ends;
+				<< " binding to socket in NetAsyncTCP::BindSocket()." << std::ends;
 		OutputErrMsg();
 		return ReturnError;
 	}
@@ -344,13 +344,13 @@
 #endif
 	{
 		*errmsg << "*** Error " << WSAGetLastError() << " getting information "
-				<< "about socket in NetAsyncTCP::BindSocket()." << ends;
+				<< "about socket in NetAsyncTCP::BindSocket()." << std::ends;
 		OutputErrMsg();
 		return ReturnError;
 	}
 
 	#if NETWORK_DETAILS || defined(_DEBUG)
-		cout << "Bound socket on port " << ntohs(address->sin_port) << "." << endl;
+		std::cout << "Bound socket on port " << ntohs(address->sin_port) << "." << std::endl;
 	#endif
 
 	return ReturnSuccess;
@@ -365,9 +365,9 @@
 {
 	// attempt to connect.
 	#if NETWORK_DETAILS || _DETAILS
-		cout << "Attempting to connect to socket at " 
+		std::cout << "Attempting to connect to socket at " 
 			 << inet_ntoa( address->sin_addr ) << ":" 
-			 << ntohs( address->sin_port ) << "." << endl;
+			 << ntohs( address->sin_port ) << "." << std::endl;
 	#endif
 
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
@@ -393,7 +393,7 @@
 						<< " connecting to " << "socket " 
 						<< inet_ntoa( address->sin_addr ) << ":" 
 						<< ntohs( address->sin_port ) 
-						<< " in NetAsyncTCP::ConnectSocket()." << ends;
+						<< " in NetAsyncTCP::ConnectSocket()." << std::ends;
 				OutputErrMsg();
 			}
 		#endif
@@ -435,7 +435,7 @@
 		Close( CLIENT );
 		if ( Create( CLIENT ) != ReturnSuccess )
 		{
-			cout << "*** Failed to re-create TCP client socket." << endl;
+			std::cout << "*** Failed to re-create TCP client socket." << std::endl;
 			return ReturnError;
 		}
 	}
@@ -474,9 +474,9 @@
 
 	// Listen to socket.
 	#if NETWORK_DETAILS || _DETAILS
-		cout << "Listening to socket " 
+		std::cout << "Listening to socket " 
 			 << inet_ntoa( server_address.sin_addr )
-			 << ":" << ntohs( server_address.sin_port ) << "." << endl;
+			 << ":" << ntohs( server_address.sin_port ) << "." << std::endl;
 	#endif
 
 	// It's ok to listen more than once on a socket.
@@ -490,7 +490,7 @@
 #endif
 		{
 			*errmsg << "*** Error " << WSAGetLastError() 
-				<< " listening to socket in NetAsyncTCP::Listen()." << ends;
+				<< " listening to socket in NetAsyncTCP::Listen()." << std::ends;
 			OutputErrMsg();
 			return ReturnError;
 		}
@@ -497,7 +497,7 @@
 
 	// Accept connections to socket.
 	#if NETWORK_DETAILS || defined(_DEBUG)
-		cout << "Accepting connections to socket." << endl;
+		std::cout << "Accepting connections to socket." << std::endl;
 	#endif
 
 	// Check the server socket for a connection request.  
@@ -521,7 +521,7 @@
 		addr_len = sizeof( client_address );
 		// Create client socket.
 		#if NETWORK_DETAILS || defined(_DEBUG)
-			cout << "Creating client socket." << endl;
+			std::cout << "Creating client socket." << std::endl;
 		#endif
 
 #if defined(IOMTR_OSFAMILY_NETWARE) || defined(IOMTR_OSFAMILY_UNIX)
@@ -531,7 +531,7 @@
 		if (((struct File *)client_socket)->fd < 0)
 		{
 			*errmsg << "*** Could not create socket in NetAsyncTCP::"
-					<< "CreateSocket(), error: " << WSAGetLastError()  << ends;
+					<< "CreateSocket(), error: " << WSAGetLastError()  << std::ends;
 			OutputErrMsg();
 			((struct File *)client_socket)->fd = (int)INVALID_SOCKET;
 			return ReturnError;
@@ -543,7 +543,7 @@
 		if ( client_socket== INVALID_SOCKET )
 		{
 			*errmsg << "*** Could not create socket in NetAsyncTCP::"
-					<< "CreateSocket(), error: " << WSAGetLastError()  << ends;
+					<< "CreateSocket(), error: " << WSAGetLastError()  << std::ends;
 			OutputErrMsg();
 			return ReturnError;
 		}
@@ -561,7 +561,7 @@
 	default:
 		// error.
 		*errmsg << "*** select() failed in NetAsyncTCP::Accept(): " 
-			<< WSAGetLastError() << ends;
+			<< WSAGetLastError() << std::ends;
 		OutputErrMsg();
 		return ReturnError;
 	}
@@ -586,7 +586,7 @@
 
 
 	#if NETWORK_DETAILS || _DETAILS
-		cout << "Waiting for other end to disconnect." << endl;
+		std::cout << "Waiting for other end to disconnect." << std::endl;
 	#endif
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
@@ -598,7 +598,7 @@
 #endif
 	{
 		#if NETWORK_DETAILS || _DETAILS
-			cout << "Socket is already closed." << endl;
+			std::cout << "Socket is already closed." << std::endl;
 		#endif
 		return ReturnSuccess;
 	}
@@ -613,7 +613,7 @@
 #endif
 	if (res == SOCKET_ERROR) {
 		#if NETWORK_DETAILS || _DETAILS
-			cout << "Not connected to anything.  Aborting WaitForDisconnect()." << endl;
+			std::cout << "Not connected to anything.  Aborting WaitForDisconnect()." << std::endl;
 		#endif
 		return ReturnSuccess;
 	}
@@ -666,7 +666,7 @@
 	LPOVERLAPPED asynchronous_io, DWORD flags )
 {
 	#if NETWORK_DETAILS || _DETAILS
-		cout << "* Receiving " << bytes << " bytes from socket." << endl;
+		std::cout << "* Receiving " << bytes << " bytes from socket." << std::endl;
 	#endif
 
 	// specify the file pointer (meaningless for a socket, but must be set)
@@ -690,8 +690,8 @@
 	{
 		// Read succeeded.
 		#if NETWORK_DETAILS || _DETAILS
-			cout << "* Received " << *return_value << " of " << bytes 
-				<< " bytes from socket." << endl;
+			std::cout << "* Received " << *return_value << " of " << bytes 
+				<< " bytes from socket." << std::endl;
 		#endif
 		return ReturnSuccess;
 	}
@@ -700,8 +700,8 @@
 	if ( WSAGetLastError() == WSA_IO_PENDING )
 	{
 		#if NETWORK_DETAILS || _DETAILS
-			cout << "* Queued receive for " << *return_value << " of " 
-				 << bytes << " bytes from socket." << endl;
+			std::cout << "* Queued receive for " << *return_value << " of " 
+				 << bytes << " bytes from socket." << std::endl;
 		#endif
 		return ReturnPending;
 	}
@@ -710,7 +710,7 @@
 	*return_value = WSAGetLastError();
 	#if NETWORK_DETAILS || _DETAILS
 		*errmsg << "*** Error " << *return_value << " receiving " 
-				<< bytes << " bytes from socket." << ends;
+				<< bytes << " bytes from socket." << std::ends;
 		OutputErrMsg();
 	#endif
 	return ReturnError;
@@ -725,7 +725,7 @@
 	LPOVERLAPPED asynchronous_io, DWORD flags )
 {
 	#if NETWORK_DETAILS || _DETAILS
-		cout << "* Sending " << bytes << " bytes to socket." << endl;
+		std::cout << "* Sending " << bytes << " bytes to socket." << std::endl;
 	#endif
 
 	// specify the file pointer (meaningless for a socket, but must be set)
@@ -749,8 +749,8 @@
 	{
 		// Write succeeded.
 		#if NETWORK_DETAILS || _DETAILS
-			cout << "* Sent " << *return_value << " of " << bytes 
-				<< " bytes to socket." << endl;
+			std::cout << "* Sent " << *return_value << " of " << bytes 
+				<< " bytes to socket." << std::endl;
 		#endif
 		return ReturnSuccess;
 	}
@@ -759,8 +759,8 @@
 	if ( WSAGetLastError() == WSA_IO_PENDING )
 	{
 		#if NETWORK_DETAILS || _DETAILS
-			cout << "* Queued send for " << *return_value << " of " 
-				 << bytes << " bytes to socket." << endl;
+			std::cout << "* Queued send for " << *return_value << " of " 
+				 << bytes << " bytes to socket." << std::endl;
 		#endif
 		return ReturnPending;
 	}
@@ -769,7 +769,7 @@
 	*return_value = WSAGetLastError();
 	#if NETWORK_DETAILS || _DETAILS
 		*errmsg << "*** Error " << *return_value << " sending " 
-				<< bytes << " bytes to socket." << ends;
+				<< bytes << " bytes to socket." << std::ends;
 		OutputErrMsg();
 	#endif
 	return ReturnError;
@@ -811,12 +811,12 @@
 #endif
 	if (res == ReturnSuccess) {
 		#if NETWORK_DETAILS || _DETAILS
-			cout << "* Peeked " << bytes_available << " bytes from socket." << endl;
+			std::cout << "* Peeked " << bytes_available << " bytes from socket." << std::endl;
 		#endif
 		return bytes_available;
 	} else {
 		#if NETWORK_DETAILS || defined(_DEBUG)
-			*errmsg << "*** Error " << t << " peeking from socket in NetAsyncTCP::Peek()." << ends;
+			*errmsg << "*** Error " << t << " peeking from socket in NetAsyncTCP::Peek()." << std::ends;
 			OutputErrMsg();
 		#endif
 		return 0;	// no data available at this time, maybe later
@@ -829,7 +829,7 @@
 ReturnVal NetAsyncTCP::CloseSocket( CONNECTION *s )
 {
 	#if NETWORK_DETAILS || _DETAILS
-		cout << "Closing socket." << endl;
+		std::cout << "Closing socket." << std::endl;
 	#endif
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
@@ -841,13 +841,13 @@
 #endif
 	{
 		#if NETWORK_DETAILS || _DETAILS
-			cout << "Socket is already closed." << endl;
+			std::cout << "Socket is already closed." << std::endl;
 		#endif
 		return ReturnSuccess;
 	}
 
 	#if NETWORK_DETAILS || defined(_DEBUG)
-		cout << "Closing socket." << endl;
+		std::cout << "Closing socket." << std::endl;
 	#endif
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
@@ -860,7 +860,7 @@
 #endif
 	{
 		*errmsg << "*** Error " << WSAGetLastError() 
-				<< " closing socket in NetAsyncTCP::CloseSocket()." << ends;
+				<< " closing socket in NetAsyncTCP::CloseSocket()." << std::ends;
 		OutputErrMsg();
 		return ReturnError;
 	}
@@ -919,23 +919,23 @@
 	struct File *fp = (struct File *) *s;
 	// When closing the connection, do a hard close.
 	if ( setsockopt( fp->fd, SOL_SOCKET, SO_LINGER, (char *) &lstruct, sizeof(lstruct) ) == SOCKET_ERROR )
-		cout << "*** Couldn't set SO_LINGER option" << endl;
+		std::cout << "*** Couldn't set SO_LINGER option" << std::endl;
 	// Reuse socket addresses
 	if ( setsockopt( fp->fd, SOL_SOCKET, SO_REUSEADDR, (char *) &setoption, sizeof(setoption) ) == SOCKET_ERROR )
-		cout << "*** Couldn't set SO_REUSEADDR option" << endl;
+		std::cout << "*** Couldn't set SO_REUSEADDR option" << std::endl;
 	// Don't delay sending data.
 	if ( setsockopt( fp->fd, IPPROTO_TCP, TCP_NODELAY, (char *) &setoption, sizeof(setoption) ) == SOCKET_ERROR )
-		cout << "*** Couldn't set TCP_NODELAY option" << endl;
+		std::cout << "*** Couldn't set TCP_NODELAY option" << std::endl;
 #elif defined(IOMTR_OSFAMILY_WINDOWS)
 	// When closing the connection, do a hard close.
 	if ( setsockopt( *s, SOL_SOCKET, SO_LINGER, (char *) &lstruct, sizeof(lstruct) ) == SOCKET_ERROR )
-		cout << "*** Couldn't set SO_LINGER option" << endl;
+		std::cout << "*** Couldn't set SO_LINGER option" << std::endl;
 	// Reuse socket addresses
 	if ( setsockopt( *s, SOL_SOCKET, SO_REUSEADDR, (char *) &setoption, sizeof(setoption) ) == SOCKET_ERROR )
-		cout << "*** Couldn't set SO_REUSEADDR option" << endl;
+		std::cout << "*** Couldn't set SO_REUSEADDR option" << std::endl;
 	// Don't delay sending data.
 	if ( setsockopt( *s, IPPROTO_TCP, TCP_NODELAY, (char *) &setoption, sizeof(setoption) ) == SOCKET_ERROR )
-		cout << "*** Couldn't set TCP_NODELAY option" << endl;
+		std::cout << "*** Couldn't set TCP_NODELAY option" << std::endl;
 #else
  #warning ===> WARNING: You have to do some coding here to get the port done! 
 #endif
@@ -948,23 +948,23 @@
 		// When closing the connection, do a hard close.
 		size = sizeof(CHECK_lstruct);
 		if ( getsockopt( *s, SOL_SOCKET, SO_LINGER, (char *) &CHECK_lstruct, &size ) == SOCKET_ERROR )
-			cout << "*** Couldn't get SO_LINGER option" << endl;
+			std::cout << "*** Couldn't get SO_LINGER option" << std::endl;
 		else if ( memcmp( &lstruct, &CHECK_lstruct, sizeof(lstruct) ) )
-			cout << "*** SO_LINGER was not set correctly" << endl;
+			std::cout << "*** SO_LINGER was not set correctly" << std::endl;
 
 		// Reuse socket addresses
 		size = sizeof(CHECK_setoption);
 		if ( getsockopt( *s, SOL_SOCKET, SO_REUSEADDR, (char *) &CHECK_setoption, &size ) == SOCKET_ERROR )
-			cout << "*** Couldn't get SO_REUSEADDR option" << endl;
+			std::cout << "*** Couldn't get SO_REUSEADDR option" << std::endl;
 		else if ( setoption != CHECK_setoption )
-			cout << "*** SO_REUSEADDR was not set correctly" << endl;
+			std::cout << "*** SO_REUSEADDR was not set correctly" << std::endl;
 
 		// Don't delay sending data.
 		size = sizeof(CHECK_setoption);
 		if ( getsockopt( *s, IPPROTO_TCP, TCP_NODELAY, (char *) &CHECK_setoption, &size ) == SOCKET_ERROR )
-			cout << "*** Couldn't get TCP_NODELAY option" << endl;
+			std::cout << "*** Couldn't get TCP_NODELAY option" << std::endl;
 		else if ( setoption != CHECK_setoption )
-			cout << "*** TCP_NODELAY was not set correctly" << endl;
+			std::cout << "*** TCP_NODELAY was not set correctly" << std::endl;
 	#endif
 #endif
 }
@@ -974,7 +974,7 @@
 //
 // Handy debugger function.  Call like so:
 //
-// cout << "*** Error: " << Error( WSAGetLastError() ) << endl;
+// std::cout << "*** Error: " << Error( WSAGetLastError() ) << std::endl;
 //
 char *NetAsyncTCP::Error(int error_num)
 {
--- iometer-1.1.0-rc1/src/IOPortTCP.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOPortTCP.cpp	Mon Aug 20 18:18:45 2012
@@ -152,7 +152,7 @@
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	if (sockets_in_use++ == 0) {
 #ifdef _DEBUG
-		cout << "Initializing WinSock." << endl << flush;
+		std::cout << "Initializing WinSock." << std::endl << std::flush;
 #endif
 
 		int retval;
@@ -162,9 +162,9 @@
 		retval = WSAStartup(MAKEWORD(2, 0), &wd);
 
 		if (retval != 0) {
-			*errmsg << "===> ERROR: Could not initialize WinSock." << endl
-			    << "     [PortTCP::PortTCP() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			    << "     retval = " << retval << ends;
+			*errmsg << "===> ERROR: Could not initialize WinSock." << std::endl
+			    << "     [PortTCP::PortTCP() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+			    << "     retval = " << retval << std::ends;
 			OutputErrMsg();
 		}
 	}
@@ -187,13 +187,13 @@
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	if (sockets_in_use-- == 0) {
 #if PORT_DETAILS || _DETAILS
-		cout << "Cleaning up WinSock." << endl;
+		std::cout << "Cleaning up WinSock." << std::endl;
 #endif
 
 		if (WSACleanup() != 0) {
-			*errmsg << "===> ERROR: Could not clean up WinSock." << endl
-			    << "     [PortTCP::~PortTCP() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			    << "     return code = " << WSAGetLastError() << ends;
+			*errmsg << "===> ERROR: Could not clean up WinSock." << std::endl
+			    << "     [PortTCP::~PortTCP() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+			    << "     return code = " << WSAGetLastError() << std::ends;
 			OutputErrMsg();
 		}
 	}
@@ -219,9 +219,9 @@
 	} else {
 		// get the unqualified local host name
 		if (gethostname(name, MAX_NETWORK_NAME) == SOCKET_ERROR) {
-			*errmsg << "===> ERROR: Getting local host name failed." << endl
-			    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			    << "     errno = " << WSAGetLastError() << ends;
+			*errmsg << "===> ERROR: Getting local host name failed." << std::endl
+			    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+			    << "     errno = " << WSAGetLastError() << std::ends;
 			OutputErrMsg();
 			return FALSE;
 		}
@@ -234,9 +234,9 @@
 		struct hostent *hostinfo = gethostbyname(name);
 
 		if (hostinfo == NULL) {
-			*errmsg << "===> ERROR: Getting host name for \"" << name << "\" failed." << endl
-			    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			    << "     errno = " << WSAGetLastError() << ends;
+			*errmsg << "===> ERROR: Getting host name for \"" << name << "\" failed." << std::endl
+			    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+			    << "     errno = " << WSAGetLastError() << std::ends;
 			OutputErrMsg();
 			return FALSE;
 		}
@@ -250,7 +250,7 @@
 	//
 
 #if PORT_DETAILS || _DETAILS
-	cout << "Creating socket." << endl;
+	std::cout << "Creating socket." << std::endl;
 	WSASetLastError(0);
 #endif
 
@@ -264,9 +264,9 @@
 #endif
 
 	if (server_socket == (int)INVALID_SOCKET) {
-		*errmsg << "===> ERROR: Creating socket failed." << endl
-		    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-		    << "     errno = " << WSAGetLastError() << ends;
+		*errmsg << "===> ERROR: Creating socket failed." << std::endl
+		    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+		    << "     errno = " << WSAGetLastError() << std::ends;
 		OutputErrMsg();
 		return FALSE;
 	}
@@ -275,7 +275,7 @@
 	//
 
 #if PORT_DETAILS || _DETAILS
-	cout << "Binding to socket " << name << "." << endl;
+	std::cout << "Binding to socket " << name << "." << std::endl;
 	WSASetLastError(0);
 #endif
 
@@ -284,9 +284,9 @@
 	sin.sin_port = htons(network_port);	// listen at specified port (0 = system assigns port number)
 
 	if (bind(server_socket, (struct sockaddr *)&sin, sizeof(sin)) != 0) {
-		*errmsg << "===> ERROR: Binding to socket " << name << " failed." << endl
-		    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-		    << "     errno = " << WSAGetLastError() << ends;
+		*errmsg << "===> ERROR: Binding to socket " << name << " failed." << std::endl
+		    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+		    << "     errno = " << WSAGetLastError() << std::ends;
 		OutputErrMsg();
 		return FALSE;
 	}
@@ -293,9 +293,9 @@
 	// get actual port number in use
 	buflen = sizeof(sin);
 	if (getsockname(server_socket, (struct sockaddr *)&sin, &buflen) != 0) {
-		*errmsg << "===> ERROR: Getting information about server socket failed." << endl
-		    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-		    << "     errno = " << WSAGetLastError() << ends;
+		*errmsg << "===> ERROR: Getting information about server socket failed." << std::endl
+		    << "     [PortTCP::Create() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+		    << "     errno = " << WSAGetLastError() << std::ends;
 		OutputErrMsg();
 		return FALSE;
 	}
@@ -302,7 +302,7 @@
 	network_port = ntohs(sin.sin_port);
 
 #if PORT_DETAILS || _DETAILS
-	cout << "Bound server socket on port " << network_port << "." << endl;
+	std::cout << "Bound server socket on port " << network_port << "." << std::endl;
 #endif
 
 	return TRUE;
@@ -326,9 +326,9 @@
 		strcpy(name, port_name);
 	} else {
 		if (gethostname(name, MAX_NETWORK_NAME) == SOCKET_ERROR) {
-			*errmsg << "===> ERROR: Getting local host name failed." << endl
-			    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			    << "     errno = " << WSAGetLastError() << ends;
+			*errmsg << "===> ERROR: Getting local host name failed." << std::endl
+			    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+			    << "     errno = " << WSAGetLastError() << std::ends;
 			OutputErrMsg();
 			return FALSE;
 		}
@@ -345,9 +345,9 @@
 		// treat it as a hostname
 		hostinfo = gethostbyname(name);
 		if (hostinfo == NULL) {
-			*errmsg << "===> ERROR: Getting host information for \"" << name << "\" failed." << endl
-			    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			    << "     errno = " << WSAGetLastError() << ends;
+			*errmsg << "===> ERROR: Getting host information for \"" << name << "\" failed." << std::endl
+			    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+			    << "     errno = " << WSAGetLastError() << std::ends;
 			OutputErrMsg();
 			return FALSE;
 		}
@@ -357,7 +357,7 @@
 	// create socket for the connnection.
 
 #if PORT_DETAILS || _DETAILS
-	cout << "Creating socket " << name << "." << endl;
+	std::cout << "Creating socket " << name << "." << std::endl;
 	WSASetLastError(0);
 #endif
 
@@ -371,9 +371,9 @@
 #endif
 
 	if (client_socket == (int)INVALID_SOCKET) {
-		*errmsg << "===> ERROR: Creating socket failed." << endl
-		    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-		    << "     errno = " << WSAGetLastError() << ends;
+		*errmsg << "===> ERROR: Creating socket failed." << std::endl
+		    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+		    << "     errno = " << WSAGetLastError() << std::ends;
 		OutputErrMsg();
 		return FALSE;
 	}
@@ -384,7 +384,7 @@
 	sin.sin_addr.s_addr = server_address;	// connect to this server
 
 #if PORT_DETAILS || _DETAILS
-	cout << "Host address: " << inet_ntoa(sin.sin_addr) << endl;
+	std::cout << "Host address: " << inet_ntoa(sin.sin_addr) << std::endl;
 #endif
 
 	// attempt to connect (keep trying forever if necessary).
@@ -391,7 +391,7 @@
 
 	do {
 #if PORT_DETAILS || _DETAILS
-		cout << "Attempting to connect to socket " << name << "." << endl;
+		std::cout << "Attempting to connect to socket " << name << "." << std::endl;
 		WSASetLastError(0);
 #endif
 
@@ -409,9 +409,9 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 			{
-				*errmsg << "===> ERROR: Connecting to socket " << name << " failed." << endl
-				    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				    << "     errno = " << WSAGetLastError() << ends;
+				*errmsg << "===> ERROR: Connecting to socket " << name << " failed." << std::endl
+				    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+				    << "     errno = " << WSAGetLastError() << std::ends;
 				OutputErrMsg();
 			}
 #endif
@@ -424,14 +424,14 @@
 			//      reconnect.
 
 #if PORT_DETAILS || _DETAILS
-			cout << "Re-creating socket " << name << "." << endl;
+			std::cout << "Re-creating socket " << name << "." << std::endl;
 			WSASetLastError(0);
 #endif
 
 			if (close(client_socket) < 0) {
-				*errmsg << "===> ERROR: Closing socket " << name << " failed." << endl
-				    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				    << "     errno = " << WSAGetLastError() << ends;
+				*errmsg << "===> ERROR: Closing socket " << name << " failed." << std::endl
+				    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+				    << "     errno = " << WSAGetLastError() << std::ends;
 				OutputErrMsg();
 				return FALSE;
 			}
@@ -438,9 +438,9 @@
 
 			if ((client_socket = socket(AF_INET, SOCK_STREAM, PF_UNSPEC))
 			    == (int)INVALID_SOCKET) {
-				*errmsg << "===> ERROR: Recreating socket " << name << " failed." << endl
-				    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-				    << "     errno = " << WSAGetLastError() << ends;
+				*errmsg << "===> ERROR: Recreating socket " << name << " failed." << std::endl
+				    << "     [PortTCP::Connect() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+				    << "     errno = " << WSAGetLastError() << std::ends;
 				OutputErrMsg();
 				return FALSE;
 			}
@@ -468,15 +468,15 @@
 	//
 
 #if PORT_DETAILS || _DETAILS
-	cout << "Listening to socket " << name << "." << endl;
+	std::cout << "Listening to socket " << name << "." << std::endl;
 	WSASetLastError(0);
 #endif
 
 	if (listen(server_socket, 0) != 0)	// allow at most one connection at a time
 	{
-		*errmsg << "===> ERROR: Listening to socket " << name << " failed." << endl
-		    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-		    << "     errno = " << WSAGetLastError() << ends;
+		*errmsg << "===> ERROR: Listening to socket " << name << " failed." << std::endl
+		    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+		    << "     errno = " << WSAGetLastError() << std::ends;
 		OutputErrMsg();
 		return FALSE;
 	}
@@ -485,7 +485,7 @@
 	//
 
 #if PORT_DETAILS || _DETAILS
-	cout << "Accepting connections to socket " << name << "." << endl;
+	std::cout << "Accepting connections to socket " << name << "." << std::endl;
 	WSASetLastError(0);
 #endif
 
@@ -494,9 +494,9 @@
 		client_socket = accept(server_socket, NULL, NULL);
 
 		if (client_socket == (int)INVALID_SOCKET) {
-			*errmsg << "===> ERROR: Accepting connection to socket " << name << " failed." << endl
-			    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			    << "     errno = " << WSAGetLastError() << ends;
+			*errmsg << "===> ERROR: Accepting connection to socket " << name << " failed." << std::endl
+			    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+			    << "     errno = " << WSAGetLastError() << std::ends;
 			OutputErrMsg();
 			return FALSE;
 		} else {
@@ -508,8 +508,8 @@
 		DWORD bytes_received;
 
 		if (!InitOverlapped(&accept_overlapped)) {
-			*errmsg << "===> ERROR: Creating OVERLAPPED structure for socket " << name << " failed." << endl
-			    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+			*errmsg << "===> ERROR: Creating OVERLAPPED structure for socket " << name << " failed." << std::endl
+			    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << std::ends;
 			OutputErrMsg();
 			return FALSE;
 		}
@@ -519,7 +519,7 @@
 		//
 
 #if PORT_DETAILS || _DETAILS
-		cout << "Creating client socket for " << name << "." << endl;
+		std::cout << "Creating client socket for " << name << "." << std::endl;
 		WSASetLastError(0);
 #endif
 
@@ -526,9 +526,9 @@
 		client_socket = WSASocket(AF_INET, SOCK_STREAM, PF_UNSPEC, NULL, 0, WSA_FLAG_OVERLAPPED);
 
 		if (client_socket == INVALID_SOCKET) {
-			*errmsg << "===> ERROR: Creating client socket for " << name << " failed." << endl
-			    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			    << "     errno = " << WSAGetLastError() << ends;
+			*errmsg << "===> ERROR: Creating client socket for " << name << " failed." << std::endl
+			    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+			    << "     errno = " << WSAGetLastError() << std::ends;
 			OutputErrMsg();
 			return FALSE;
 		}
@@ -539,7 +539,7 @@
 			     sizeof(struct sockaddr_in) + 16, sizeof(struct sockaddr_in) + 16,
 			     &bytes_received, &accept_overlapped)) {
 #if PORT_DETAILS || _DETAILS
-			cout << "Connection accepted." << endl;
+			std::cout << "Connection accepted." << std::endl;
 #endif
 
 			return TRUE;
@@ -548,8 +548,8 @@
 			{
 				return TRUE;
 			} else {
-				*errmsg << "===> ERROR: AcceptEx() failed." << endl
-				    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+				*errmsg << "===> ERROR: AcceptEx() failed." << std::endl
+				    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << std::ends;
 				OutputErrMsg();
 				return FALSE;
 			}
@@ -557,8 +557,8 @@
 	}
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
-		*errmsg << "===> ERROR: Attempting asynchronous connection in Unix." << endl
-		    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		*errmsg << "===> ERROR: Attempting asynchronous connection in Unix." << std::endl
+		    << "     [PortTCP::Accept() in " << __FILE__ << " line " << __LINE__ << "]" << std::ends;
 		OutputErrMsg();
 		return (FALSE);
 	}
@@ -593,8 +593,8 @@
 
 	return result;
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-	*errmsg << "===> ERROR: Asynchronous socket accept attempted under Unix." << endl
-	    << "     [PortTCP::GetAcceptResult() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+	*errmsg << "===> ERROR: Asynchronous socket accept attempted under Unix." << std::endl
+	    << "     [PortTCP::GetAcceptResult() in " << __FILE__ << " line " << __LINE__ << "]" << std::ends;
 	OutputErrMsg();
 	return (FALSE);
 #else
@@ -631,8 +631,8 @@
 	}
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
-		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << endl
-		    << "     [PortTCP::Receive() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << std::endl
+		    << "     [PortTCP::Receive() in " << __FILE__ << " line " << __LINE__ << "]" << std::ends;
 		OutputErrMsg();
 		return (0);
 	}
@@ -658,11 +658,11 @@
 		bytes_read = recv(client_socket, (char *)msg, size, 0);
 		if (bytes_read == 0 || bytes_read == SOCKET_ERROR) {
 			// socket has been closed, return error
-			cerr << "Get port error in SynchReceive." << endl;
+			std::cerr << "Get port error in SynchReceive." << std::endl;
 			return PORT_ERROR;
 		}
 #if PORT_DETAILS || _DETAILS
-		cout << "Received " << bytes_read << " of " << size << " bytes from socket " << name << "." << endl;
+		std::cout << "Received " << bytes_read << " of " << size << " bytes from socket " << name << "." << std::endl;
 #endif
 
 		total_bytes_read += bytes_read;	// add bytes read so far to total
@@ -686,8 +686,8 @@
 	DWORD bytes_read;
 
 	if (!InitOverlapped(&receive_overlapped)) {
-		*errmsg << "===> ERROR: Creating OVERLAPPED structure for socket " << name << " failed." << endl
-		    << "     [PortTCP::AsynchReceive() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		*errmsg << "===> ERROR: Creating OVERLAPPED structure for socket " << name << " failed." << std::endl
+		    << "     [PortTCP::AsynchReceive() in " << __FILE__ << " line " << __LINE__ << "]" << std::ends;
 		OutputErrMsg();
 		return PORT_ERROR;
 	}
@@ -694,7 +694,7 @@
 
 	if (ReadFile((HANDLE) client_socket, msg, size, &bytes_read, &receive_overlapped)) {
 #if PORT_DETAILS || _DETAILS
-		cout << "Received " << bytes_read << " of " << size << " bytes from socket " << name << "." << endl;
+		std::cout << "Received " << bytes_read << " of " << size << " bytes from socket " << name << "." << std::endl;
 #endif
 
 		return (DWORDLONG) bytes_read;
@@ -707,8 +707,8 @@
 	}
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
-		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << endl
-		    << "     [PortTCP::AsynchReceive() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << std::endl
+		    << "     [PortTCP::AsynchReceive() in " << __FILE__ << " line " << __LINE__ << "]" << std::ends;
 		OutputErrMsg();
 		return (PORT_ERROR);
 	}
@@ -741,8 +741,8 @@
 	}
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
-		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << endl
-		    << "     [PortTCP::GetReceiveResult() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << std::endl
+		    << "     [PortTCP::GetReceiveResult() in " << __FILE__ << " line " << __LINE__ << "]" << std::ends;
 		OutputErrMsg();
 		return (PORT_ERROR);
 	}
@@ -779,7 +779,7 @@
 	static int error_count=0;
 
 #ifdef _DEBUG
-	cout << "in SynchSend " << endl;
+	std::cout << "in SynchSend " << std::endl;
 #endif
 	while (total_bytes_written < total_size) {
 		bytes_written = send(client_socket, (char *)msg, size, 0);
@@ -788,10 +788,10 @@
 			error_count++;
 			if (error_count == 1 || error_count%10 == 0) {
 				// socket has been closed, return error
-				*errmsg << "===> ERROR: Send failed." << endl
-					<< "     [PortTCP::SynchSend() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-					<< "     errno = " << WSAGetLastError() << endl
-					<< "     error repeats " << error_count << " time(s)." << ends;
+				*errmsg << "===> ERROR: Send failed." << std::endl
+					<< "     [PortTCP::SynchSend() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+					<< "     errno = " << WSAGetLastError() << std::endl
+					<< "     error repeats " << error_count << " time(s)." << std::ends;
 
 				OutputErrMsg();
 			}
@@ -801,10 +801,10 @@
 		{
 			if (error_count)
 			{
-				*errmsg << "===> ERROR: Send failed." << endl
-					<< "     [PortTCP::SynchSend() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-					<< "     errno = " << WSAGetLastError() << endl
-					<< "     error repeated " << error_count << " time(s)." << ends;
+				*errmsg << "===> ERROR: Send failed." << std::endl
+					<< "     [PortTCP::SynchSend() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+					<< "     errno = " << WSAGetLastError() << std::endl
+					<< "     error repeated " << error_count << " time(s)." << std::ends;
 				OutputErrMsg();
 			}
 
@@ -812,7 +812,7 @@
 		}
 
 #if PORT_DETAILS || _DETAILS
-		cout << "Sent " << bytes_written << " of " << size << " bytes to socket " << name << "." << endl;
+		std::cout << "Sent " << bytes_written << " of " << size << " bytes to socket " << name << "." << std::endl;
 #endif
 
 		total_bytes_written += bytes_written;	// add bytes written so far to total
@@ -840,7 +840,7 @@
 
 	if (WriteFile((HANDLE) client_socket, msg, size, &bytes_written, &send_overlapped)) {
 #if PORT_DETAILS || _DETAILS
-		cout << "Sent " << bytes_written << " of " << size << " bytes to socket " << name << "." << endl;
+		std::cout << "Sent " << bytes_written << " of " << size << " bytes to socket " << name << "." << std::endl;
 #endif
 		return (DWORDLONG) bytes_written;
 	} else {
@@ -852,8 +852,8 @@
 	}
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
-		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << endl
-		    << "     [PortTCP::AsynchSend() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << std::endl
+		    << "     [PortTCP::AsynchSend() in " << __FILE__ << " line " << __LINE__ << "]" << std::ends;
 		OutputErrMsg();
 		return (PORT_ERROR);
 	}
@@ -881,8 +881,8 @@
 	}
 #elif defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 	else {
-		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << endl
-		    << "     [PortTCP::GetSendResult() in " << __FILE__ << " line " << __LINE__ << "]" << ends;
+		*errmsg << "===> ERROR: Asynchronous TCP attempted under Unix." << std::endl
+		    << "     [PortTCP::GetSendResult() in " << __FILE__ << " line " << __LINE__ << "]" << std::ends;
 		OutputErrMsg();
 		return (PORT_ERROR);
 	}
@@ -937,14 +937,14 @@
 
 	if (success) {
 #if PORT_DETAILS || _DETAILS
-		cout << "Peeked " << bytes_available << " bytes from socket " << name << "." << endl;
+		std::cout << "Peeked " << bytes_available << " bytes from socket " << name << "." << std::endl;
 #endif
 		return (DWORD) bytes_available;
 	} else {
 #if PORT_DETAILS || _DETAILS
-		*errmsg << "===> ERROR: Peeking from socket " << name << " failed." << endl
-		    << "     [PortTCP::Peek() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-		    << "     errno = " << WSAGetLastError() << ends;
+		*errmsg << "===> ERROR: Peeking from socket " << name << " failed." << std::endl
+		    << "     [PortTCP::Peek() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+		    << "     errno = " << WSAGetLastError() << std::ends;
 		OutputErrMsg();
 #endif
 		return 0;	// no data available at this time, maybe later
@@ -958,12 +958,12 @@
 {
 	if (*s == (int)INVALID_SOCKET) {
 #if PORT_DETAILS || _DETAILS
-		cout << socket_name << " socket is already closed." << endl;
+		std::cout << socket_name << " socket is already closed." << std::endl;
 #endif
 		return TRUE;
 	}
 #if PORT_DETAILS || _DETAILS
-	cout << "Shutting down " << socket_name << " socket." << endl;
+	std::cout << "Shutting down " << socket_name << " socket." << std::endl;
 #endif
 
 	if (shutdown(*s, SD_BOTH) != 0) {
@@ -971,19 +971,19 @@
 		// WSAENOTCONN = "socket is not connected", which occurs on the server side if the socket is
 		// closed with no Accept() active -- this is no problem since we're just closing it anyway
 		if (WSAGetLastError() != WSAENOTCONN) {
-			*errmsg << "===> ERROR: Shutting down socket " << socket_name << " failed." << endl
-			    << "     [PortTCP::CloseSocket() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-			    << "     errno = " << WSAGetLastError() << ends;
+			*errmsg << "===> ERROR: Shutting down socket " << socket_name << " failed." << std::endl
+			    << "     [PortTCP::CloseSocket() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+			    << "     errno = " << WSAGetLastError() << std::ends;
 			OutputErrMsg();
 			return FALSE;
 		}
 #endif
 #if PORT_DETAILS || _DETAILS
-		cout << socket_name << " socket is already shut down." << endl;
+		std::cout << socket_name << " socket is already shut down." << std::endl;
 #endif
 	}
 #if PORT_DETAILS || _DETAILS
-	cout << "Closing " << socket_name << " socket." << endl;
+	std::cout << "Closing " << socket_name << " socket." << std::endl;
 #endif
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
@@ -994,9 +994,9 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
-		*errmsg << "===> ERROR: Closing socket " << socket_name << " failed." << endl
-		    << "     [PortTCP::CloseSocket() in " << __FILE__ << " line " << __LINE__ << "]" << endl
-		    << "     errno = " << WSAGetLastError() << ends;
+		*errmsg << "===> ERROR: Closing socket " << socket_name << " failed." << std::endl
+		    << "     [PortTCP::CloseSocket() in " << __FILE__ << " line " << __LINE__ << "]" << std::endl
+		    << "     errno = " << WSAGetLastError() << std::ends;
 		OutputErrMsg();
 		return FALSE;
 	}
--- iometer-1.1.0-rc1/src/IOPort.h.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOPort.h	Mon Aug 20 18:18:41 2012
@@ -68,7 +68,7 @@
 /* ##               2003-02-15 (daniel.scheibli@edelbyte.org)             ## */
 /* ##               - Added new header holding the changelog.             ## */
 /* ##               - Different changes to support compilation with       ## */
-/* ##                 gcc 3.2 (known as cout << hex error).               ## */
+/* ##                 gcc 3.2 (known as std::cout << hex error).               ## */
 /* ##                                                                     ## */
 /* ######################################################################### */
 #ifndef PORT_DEFINED
@@ -78,7 +78,6 @@
 namespace std {
 }
 #endif
-using namespace std;
 
 #include <sstream>
 
@@ -135,7 +134,7 @@
 	// private data members common to all Ports
 	 BOOL synchronous;
 	char name[MAX_NETWORK_NAME];
-	ostringstream *errmsg;
+	std::ostringstream *errmsg;
 
 	// private functions common to all Ports (implemented by Port)
 	virtual void OutputErrMsg();
--- iometer-1.1.0-rc1/src/Manager.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/Manager.cpp	Mon Aug 20 18:18:46 2012
@@ -669,7 +669,7 @@
 	for (stat = 0; stat < TCP_RESULTS; stat++)
 		(*file) << "," << results[WHOLE_TEST_PERF].tcp_statistics[stat];
 
-	(*file) << endl;
+	(*file) << std::endl;
 
 	// Save individual CPU results.
 	for (int cpu = 0; cpu < processors; cpu++) {
@@ -686,7 +686,7 @@
 		for (stat = 0; stat < NI_COMBINE_RESULTS + TCP_RESULTS; stat++)
 			(*file) << ",";	// space for network results
 
-		(*file) << endl;
+		(*file) << std::endl;
 	}
 
 	// If requested, save workers' results.
@@ -1711,14 +1711,14 @@
 {
 	int wkr_count = WorkerCount();
 
-	outfile << "'Manager ID, manager name" << endl << "\t" << id << "," << name << endl;
-	outfile << "'Manager network address" << endl << "\t" << network_name << endl;
+	outfile << "'Manager ID, manager name" << std::endl << "\t" << id << "," << name << std::endl;
+	outfile << "'Manager network address" << std::endl << "\t" << network_name << std::endl;
 
 	for (int counter = 0; counter < wkr_count; counter++)
 		if (!GetWorker(counter)->SaveConfig(outfile, save_aspecs, save_targets))
 			return FALSE;	// error saving data - propagate back
 
-	outfile << "'End manager" << endl;
+	outfile << "'End manager" << std::endl;
 	return TRUE;
 }
 
--- iometer-1.1.0-rc1/src/IOVIPL.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOVIPL.cpp	Mon Aug 20 18:18:46 2012
@@ -169,7 +169,7 @@
 	// Load vipl.dll.
 	if (!(vipl_dll = LoadLibrary("vipl.dll"))) {
 #ifdef _DEBUG
-		cout << "Unable to load vipl.dll" << endl;
+		std::cout << "Unable to load vipl.dll" << std::endl;
 #endif
 		return;
 	}
@@ -253,7 +253,7 @@
 	// When VI library becomes available on Solaris, this should work
 	if ((vipl_dll = dlopen("vipl.so", RTLD_NOW | RTLD_GLOBAL | RTLD_PARENT)) == NULL) {
 #ifdef _DEBUG
-		cout << "unable to load VI shared library" << endl;
+		std::cout << "unable to load VI shared library" << std::endl;
 #endif
 		return;
 	}
@@ -362,7 +362,7 @@
 //
 // Handy debugger function.  Call like so:
 //
-// cout << "*** Error: " << vipl.Error( result ) << endl;
+// std::cout << "*** Error: " << vipl.Error( result ) << std::endl;
 //
 char *VIPL::Error(VIP_RETURN result)
 {
--- iometer-1.1.0-rc1/src/IOManagerSolaris.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOManagerSolaris.cpp	Mon Aug 20 18:18:46 2012
@@ -111,7 +111,7 @@
 
 //      int             i;
 
-	cout << "Reporting drive information..." << endl;
+	std::cout << "Reporting drive information..." << std::endl;
 
 	// *********************************************************************************
 	// DEVELOPER NOTES
@@ -159,7 +159,7 @@
 	// **********************************************************************************
 
 	// Reporting Logical drives first (filesystems).
-	cout << "  Logical drives (mounted filesystems)..." << endl;
+	std::cout << "  Logical drives (mounted filesystems)..." << std::endl;
 
 	if ((mnttab = getenv("MNTTAB")) == NULL)
 		mnttab = MNTTAB_FILE;
@@ -167,8 +167,8 @@
 	FILE *fp;
 
 	if ((fp = fopen(mnttab, "r")) == NULL) {
-		cout << "open (mount tab) file " << mnttab << " failed with error " << errno << endl;
-		cout << "Set environment variable MNTTAB to correct pathname" << endl;
+		std::cout << "open (mount tab) file " << mnttab << " failed with error " << errno << std::endl;
+		std::cout << "Set environment variable MNTTAB to correct pathname" << std::endl;
 		exit(1);
 	}
 
@@ -183,8 +183,8 @@
 			continue;
 
 		if (hasmntopt(&mtab, "forcedirectio") == NULL) {
-			cout << "NOTICE: filesystem " << mtab.mnt_mountp
-			    << " not mounted with option - forcedirectio" << endl;
+			std::cout << "NOTICE: filesystem " << mtab.mnt_mountp
+			    << " not mounted with option - forcedirectio" << std::endl;
 			// continue;            // enable only if we do not want to report this disk.
 			buffered = TRUE;
 			this->is_buffered = TRUE;
@@ -218,7 +218,7 @@
 		strcat(disk_spec[count].name, "]");
 
 #ifdef _DEBUG
-		cout << "   Found " << disk_spec[count].name << "." << endl << flush;
+		std::cout << "   Found " << disk_spec[count].name << "." << std::endl << std::flush;
 #endif
 		count++;
 		if (count >= MAX_TARGETS)
@@ -227,11 +227,11 @@
 	fclose(fp);
 
 	if (this->is_buffered) {
-		cout << endl
+		std::cout << std::endl
 		    << "NOTICE: One or more filesystems not mounted with 'forcedirecio'"
-		    << endl
+		    << std::endl
 		    << "        option set. All I/O will be via kernel buffers."
-		    << endl << "  --->  See mount(1), mount_ufs(1) for details." << endl << endl;
+		    << std::endl << "  --->  See mount(1), mount_ufs(1) for details." << std::endl << std::endl;
 		this->is_buffered = FALSE;
 	}
 
@@ -239,7 +239,7 @@
 		return count;
 
 	// Now reporting physical drives (raw devices)
-	cout << "  Physical drives (raw devices)..." << endl;
+	std::cout << "  Physical drives (raw devices)..." << std::endl;
 	int logical_count = count;
 
 	// Get a list of all the swap devices into a static public variable.
@@ -301,7 +301,7 @@
 			memcpy(&disk_spec[count], &d.spec, sizeof(Target_Spec));
 			d.spec.type = PhysicalDiskType;
 #ifdef _DEBUG
-			cout << "   Found " << disk_spec[count].name << "." << endl << flush;
+			std::cout << "   Found " << disk_spec[count].name << "." << std::endl << std::flush;
 #endif
 			count++;
 			if (count >= MAX_TARGETS)
@@ -313,19 +313,19 @@
 	// sort all the raw disk names in disk_spec array.
 	Sort_Raw_Disk_Names(disk_spec, logical_count, count);
 	if (this->is_destructive) {
-		cout << endl
+		std::cout << std::endl
 		    << "NOTICE: One or more disk partitions/slices ignored because Iometer"
-		    << endl
+		    << std::endl
 		    << "        detected the presence of file systems."
-		    << endl
+		    << std::endl
 		    << "  --->  To enable access to the partition/slice mount it or destroy"
-		    << endl
+		    << std::endl
 		    << "        it or over-ride protection by setting the IOMTR_SETTING_OVERRIDE_FS"
-		    << endl << "        environment var." << endl << endl;
+		    << std::endl << "        environment var." << std::endl << std::endl;
 		this->is_destructive = FALSE;
 	}
 
-	cout << "   done." << endl << flush;
+	std::cout << "   done." << std::endl << std::flush;
 	return count;
 }
 
@@ -349,13 +349,13 @@
 	// We don't deal directly with slices cXtXdXsX. Never gets that value.
 	snprintf(file_name, MAX_NAME, "%s/%s", RAW_DEVICE_DIR, name);
 #ifdef _DEBUG
-	cout << "   Reporting disk partitions: " << file_name << endl << flush;
+	std::cout << "   Reporting disk partitions: " << file_name << std::endl << std::flush;
 #endif
 
 	fd = open(file_name, O_RDWR | O_LARGEFILE, S_IRUSR | S_IWUSR);
 	if (fd < 0) {
 #ifdef _DEBUG
-		cout << "  open failed.." << endl << flush;
+		std::cout << "  open failed.." << std::endl << std::flush;
 #endif
 		return (TRUE);
 	}
@@ -363,7 +363,7 @@
 	if ((bytes_read = read(fd, buffer, 512)) < 512) {
 		// cannot read start sector. Disk might be bad.
 #ifdef _DEBUG
-		cout << "  read failed.. returning" << endl << flush;
+		std::cout << "  read failed.. returning" << std::endl << std::flush;
 #endif
 		close(fd);
 		return (TRUE);
@@ -382,7 +382,7 @@
 		// We do have partitions.
 		strncpy(base_name, name, (strstr(name, "p0") - name));
 #ifdef _DEBUG
-		cout << "   basename: " << base_name << endl << flush;
+		std::cout << "   basename: " << base_name << std::endl << std::flush;
 #endif
 		for (i = 1; i <= FD_NUMPART; i++) {
 			ip = (struct ipart *)(buffer + BOOTSZ + ((i - 1) * sizeof(struct ipart)));
@@ -400,7 +400,7 @@
 
 			snprintf(file_name, MAX_NAME, "%sp%d", base_name, i);
 #ifdef _DEBUG
-			cout << "   file_name: " << file_name << endl << flush;
+			std::cout << "   file_name: " << file_name << std::endl << std::flush;
 #endif
 			// check if this is a swap device. Search the global string.
 			if (strstr(swap_devices, file_name))
@@ -419,13 +419,13 @@
 				if (Has_File_System(file_name, fstype) == TRUE) {
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
 					if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL) {
-						cout << "WARNING: allowing raw access to unmounted fs: "
-						    << file_name << endl;
+						std::cout << "WARNING: allowing raw access to unmounted fs: "
+						    << file_name << std::endl;
 					} else	// environ variable not set
 					{
 #endif
-						cout << "NOTICE: ignoring " << file_name
-						    << ". File system found on disk" << endl;
+						std::cout << "NOTICE: ignoring " << file_name
+						    << ". File system found on disk" << std::endl;
 						this->is_destructive = TRUE;
 						continue;	// jump to start of for-loop
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
@@ -507,7 +507,7 @@
 
 				d.spec.type = PhysicalDiskType;
 #ifdef _DEBUG
-				cout << "   Found " << disk_spec[*count].name << "." << endl << flush;
+				std::cout << "   Found " << disk_spec[*count].name << "." << std::endl << std::flush;
 #endif
 				(*count)++;
 				FDISK_table_valid = TRUE;
@@ -516,7 +516,7 @@
 			} else {
 				// partition access failed.                             
 #ifdef _DEBUG
-				cout << "   Not found " << file_name << endl << flush;
+				std::cout << "   Not found " << file_name << std::endl << std::flush;
 #endif
 			}
 		}
@@ -551,12 +551,12 @@
 
 	snprintf(file_name, MAX_NAME, "%s/%s", RAW_DEVICE_DIR, name);
 #ifdef _DEBUG
-	cout << "   Reporting vtoc partitions: " << file_name << endl << flush;
+	std::cout << "   Reporting vtoc partitions: " << file_name << std::endl << std::flush;
 #endif
 	fd = open(file_name, O_RDWR | O_LARGEFILE, S_IRUSR | S_IWUSR);
 	if (fd < 0) {
 #ifdef _DEBUG
-		cout << "  open failed.." << endl << flush;
+		std::cout << "  open failed.." << std::endl << std::flush;
 #endif
 		return (TRUE);
 	}
@@ -577,7 +577,7 @@
 
 	strncpy(base_name, name, (strstr(name, "s2") - name));
 #ifdef _DEBUG
-	cout << "  vtoc basename: " << base_name << endl << flush;
+	std::cout << "  vtoc basename: " << base_name << std::endl << std::flush;
 #endif
 
 	for (i = 0; i < this_vtoc.v_nparts; i++) {
@@ -664,7 +664,7 @@
 			// We do not care about overlapping empty slices.
 			// Also check if overlap is with a swap slice.
 #ifdef _DEBUG
-			cerr << "NOTE: Overlapping slices : " << i << ", " << j << endl;
+			std::cerr << "NOTE: Overlapping slices : " << i << ", " << j << std::endl;
 #endif
 			snprintf(temp, MAX_NAME, "%ss%d", base_name, j);
 			if (Has_File_System(temp, fstype) == TRUE) {
@@ -680,7 +680,7 @@
 		// Here we do have VTOC parts to report.
 		snprintf(file_name, MAX_NAME, "%ss%d", base_name, i);
 #ifdef _DEBUG
-		cout << "  vtoc  file_name: " << file_name << endl << flush;
+		std::cout << "  vtoc  file_name: " << file_name << std::endl << std::flush;
 #endif
 		// check if this is a swap device. Search the global string.
 		if (strstr(swap_devices, file_name))
@@ -696,12 +696,12 @@
 			if (Has_File_System(file_name, fstype) == TRUE) {
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
 				if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL) {
-					cout << "WARNING: allowing raw access to unmounted fs: " << file_name << endl;
+					std::cout << "WARNING: allowing raw access to unmounted fs: " << file_name << std::endl;
 				} else	// environ variable not set
 				{
 #endif
-					cout << "NOTICE: ignoring " << file_name << ". file system found on disk" <<
-					    endl;
+					std::cout << "NOTICE: ignoring " << file_name << ". file system found on disk" <<
+					    std::endl;
 					this->is_destructive = TRUE;
 					continue;
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
@@ -770,7 +770,7 @@
 
 			d.spec.type = PhysicalDiskType;
 #ifdef _DEBUG
-			cout << "   Found " << disk_spec[*count].name << "." << endl << flush;
+			std::cout << "   Found " << disk_spec[*count].name << "." << std::endl << std::flush;
 #endif
 			(*count)++;
 			if (*count >= MAX_TARGETS)
@@ -798,13 +798,13 @@
 					if (Has_File_System(file_name, fstype) == TRUE) {
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
 						if (getenv("IOMTR_SETTING_OVERRIDE_FS") != NULL) {
-							cout << "WARNING: allowing raw access to unmounted fs: " <<
-							    file_name << endl;
+							std::cout << "WARNING: allowing raw access to unmounted fs: " <<
+							    file_name << std::endl;
 						} else	// environ variable not set
 						{
 #endif
-							cout << "NOTICE: ignoring " << file_name <<
-							    ". file system found on disk" << endl;
+							std::cout << "NOTICE: ignoring " << file_name <<
+							    ". file system found on disk" << std::endl;
 							this->is_destructive = TRUE;
 							continue;
 #if defined(IOMTR_SETTING_OVERRIDE_FS)
@@ -834,7 +834,7 @@
 
 					d.spec.type = PhysicalDiskType;
 #ifdef _DEBUG
-					cout << "   Found " << disk_spec[*count].name << "." << endl << flush;
+					std::cout << "   Found " << disk_spec[*count].name << "." << std::endl << std::flush;
 #endif
 					(*count)++;
 					if (*count >= MAX_TARGETS)
@@ -897,8 +897,8 @@
 	strcpy(rstr, rdisk);
 
 	if ((fp = fopen(mnttab, "r")) == NULL) {
-		cout << "open (mount tab) file " << mnttab << " failed with error " << errno << endl;
-		cout << "Set environment variable MNTTAB to correct pathname" << endl;
+		std::cout << "open (mount tab) file " << mnttab << " failed with error " << errno << std::endl;
+		std::cout << "Set environment variable MNTTAB to correct pathname" << std::endl;
 		// We wont try to report any disk. Could expose the OS partition to destructive tests.
 		return TRUE;
 	}
@@ -907,8 +907,8 @@
 		// Initialize the mpref structure to NULL. Solaris does'nt do it.
 		memset(&mpref, 0, sizeof(struct mnttab));
 #ifdef _DEBUG
-		cout << "checking if physical disk already reported as logical." << endl
-		    << "	logical disk : " << spec[i].name << " physical disk : " << rdisk << endl;
+		std::cout << "checking if physical disk already reported as logical." << std::endl
+		    << "	logical disk : " << spec[i].name << " physical disk : " << rdisk << std::endl;
 #endif
 		// check for this pattern is also in Manager::Report_Disks()
 		// and TargetDisk::Init_Logical().
@@ -924,8 +924,8 @@
 				// further the entry is in the list of reported logical disks.
 				// So, this physical disk has already been reported as a logical disk.
 #ifdef _DEBUG
-				cout << "physical disk " << rdisk << " reported logical disk "
-				    << mtab.mnt_mountp << endl;
+				std::cout << "physical disk " << rdisk << " reported logical disk "
+				    << mtab.mnt_mountp << std::endl;
 #endif
 				fclose(fp);
 				return TRUE;
@@ -1098,7 +1098,7 @@
 		// Request filling the swaptable
 
 		if ((n = swapctl(SC_LIST, pSwapTable)) < 0) {
-			cerr << "WARN: swapctl failed with error " << errno << endl;
+			std::cerr << "WARN: swapctl failed with error " << errno << std::endl;
 			free(pSwapTable);
 			free(pcSwapNames);
 			return;
@@ -1125,7 +1125,7 @@
 			strcat(swap_devices, ":");
 		}
 #ifdef _DEBUG
-		cout << "swap devices: " << swap_devices << endl;
+		std::cout << "swap devices: " << swap_devices << std::endl;
 #endif
 		free(pSwapTable);
 		free(pcSwapNames);
--- iometer-1.1.0-rc1/src/IOCQAIO.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOCQAIO.cpp	Mon Aug 20 18:18:46 2012
@@ -78,7 +78,7 @@
 	completion_queue = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
 
 	if (completion_queue == INVALID_HANDLE_VALUE) {
-		cout << "*** Unable to create I/O completion port for asynchronous " << "I/O operations." << endl;
+		std::cout << "*** Unable to create I/O completion port for asynchronous " << "I/O operations." << std::endl;
 	}
 }
 
@@ -119,7 +119,7 @@
 		return ReturnAbort;
 	}
 	// Unknown error occurred.
-	cout << "*** Error " << error_no << " occurred while getting queued " << "completion status." << endl;
+	std::cout << "*** Error " << error_no << " occurred while getting queued " << "completion status." << std::endl;
 	return ReturnError;
 }
 
@@ -136,7 +136,7 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	if (this_cqid->element_list == NULL) {
-		cout << "memory allocation failed." << endl;
+		std::cout << "memory allocation failed." << std::endl;
 		return (FALSE);
 	}
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
@@ -147,7 +147,7 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	if (this_cqid->aiocb_list == NULL) {
-		cout << "memory allocation failed." << endl;
+		std::cout << "memory allocation failed." << std::endl;
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 		free(this_cqid->element_list);
 #elif defined(IOMTR_OS_NETWARE)
@@ -163,7 +163,7 @@
 	memset(this_cqid->element_list, 0, sizeof(struct CQ_Element) * size);
 
 #ifdef _DEBUG
-	cout << "allocated a completion queue of size " << size << " for handle : " << this_cqid << endl;
+	std::cout << "allocated a completion queue of size " << size << " for handle : " << this_cqid << std::endl;
 #endif
 	return (TRUE);
 }
--- iometer-1.1.0-rc1/src/IOManager.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOManager.cpp	Mon Aug 20 18:18:46 2012
@@ -145,7 +145,7 @@
 
 	prt = new PortTCP;
 	if (!prt->Create()) {
-		cout << "*** Could not create a TCP/IP Port. exiting....." << endl;
+		std::cout << "*** Could not create a TCP/IP Port. exiting....." << std::endl;
 		exit(1);
 	}
 
@@ -162,7 +162,7 @@
 	{
 		// non-fatal
 	#ifdef _DEBUG
-		cout << " Could not get Windows version info, error=" << GetLastError() << "." << endl;
+		std::cout << " Could not get Windows version info, error=" << GetLastError() << "." << std::endl;
 	#endif	
 		ZeroMemory(&m_OsVersionInfo, sizeof(m_OsVersionInfo));
 	}
@@ -246,8 +246,8 @@
 
 	if (manager_name[0] != '\0') {
 		if (strlen(manager_name) > MAX_NETWORK_NAME) {
-			cout << "*** Specified manager name cannot be more than "
-			    << MAX_NETWORK_NAME << " characters" << endl;
+			std::cout << "*** Specified manager name cannot be more than "
+			    << MAX_NETWORK_NAME << " characters" << std::endl;
 			exit(1);
 		}
 
@@ -257,7 +257,7 @@
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 		// This will not work correctly if hostname length > MAX_NETWORK_NAME
 		if (gethostname(manager_name, name_size) < 0) {
-			cout << "*** Exiting... gethostname() returned error " << errno << endl;
+			std::cout << "*** Exiting... gethostname() returned error " << errno << std::endl;
 			exit(1);
 		}
 		name_size = strlen(data_msg->data.manager_info.names[0]);
@@ -320,10 +320,10 @@
 
 
 	// Sending login request message.
-	cout << "Sending login request..." << endl;
-	cout << "   " << data_msg->data.manager_info.names[0] << endl;
-	cout << "   " << data_msg->data.manager_info.names[1]
-	    << " (port " << data_msg->data.manager_info.port_number << ")" << endl;
+	std::cout << "Sending login request..." << std::endl;
+	std::cout << "   " << data_msg->data.manager_info.names[0] << std::endl;
+	std::cout << "   " << data_msg->data.manager_info.names[1]
+	    << " (port " << data_msg->data.manager_info.port_number << ")" << std::endl;
 
 	if (prt->type == PORT_TYPE_TCP) {
 		login_port = new PortTCP;
@@ -331,11 +331,11 @@
 		if (!login_port_number)
 			login_port_number = WELL_KNOWN_TCP_PORT;
 		if (!login_port->Connect(port_name, login_port_number)) {
-			cout << "*** Could not create TCP/IP port to connect with Iometer!" << endl;
+			std::cout << "*** Could not create TCP/IP port to connect with Iometer!" << std::endl;
 			return FALSE;
 		}
 	} else {
-		cout << "*** Invalid port type in Manager::Login()" << endl;
+		std::cout << "*** Invalid port type in Manager::Login()" << std::endl;
 		return FALSE;
 	}
 
@@ -353,7 +353,7 @@
 
 	// wait to receive reply to login request, then get the incoming message...
 	if (login_port->Receive(&reply) == PORT_ERROR) {
-		cout << endl << "*** Unable to receive a reply from Iometer" << endl;
+		std::cout << std::endl << "*** Unable to receive a reply from Iometer" << std::endl;
 		return FALSE;
 	}
 
@@ -366,22 +366,22 @@
 	// process the login reply message from Iometer
 	switch (reply.data) {
 	case WRONG_VERSION:
-		cout << endl << "*** Incorrect version of Dynamo for this Iometer" << endl;
+		std::cout << std::endl << "*** Incorrect version of Dynamo for this Iometer" << std::endl;
 		return FALSE;
 
 	case LOGIN_OK:
 		//
 		// Waiting for login to be accepted.
-		cout << endl;
-		cout << "*** If dynamo and iometer hangs here, please make sure" << endl;
-		cout << "*** you use a correct -m <manager_computer_name> that" << endl;
-		cout << "*** can ping from iometer machine. use IP if need." << endl;
+		std::cout << std::endl;
+		std::cout << "*** If dynamo and iometer hangs here, please make sure" << std::endl;
+		std::cout << "*** you use a correct -m <manager_computer_name> that" << std::endl;
+		std::cout << "*** can ping from iometer machine. use IP if need." << std::endl;
 
 		if (prt->Accept())
-			cout << "   Login accepted." << endl << flush;
+			std::cout << "   Login accepted." << std::endl << std::flush;
 		return TRUE;
 	default:
-		cout << endl << "*** Bad login status reply received - don't know what to do" << endl;
+		std::cout << std::endl << "*** Bad login status reply received - don't know what to do" << std::endl;
 		return FALSE;
 	}
 }
@@ -403,13 +403,13 @@
 	int count = 0;
 	int i;
 
-	cout << "Reporting TCP network information..." << endl;
+	std::cout << "Reporting TCP network information..." << std::endl;
 
 #if defined(IOMTR_OSFAMILY_WINDOWS)
 	// initialize WinSock version 2.0
 	retval = WSAStartup(MAKEWORD(2, 0), &wd);
 	if (retval != 0) {
-		cout << "*** Error " << retval << "initializing WinSock." << endl;
+		std::cout << "*** Error " << retval << "initializing WinSock." << std::endl;
 		return 0;
 	}
 #endif
@@ -416,13 +416,13 @@
 
 	// get the unqualified local host name
 	if (gethostname(hostname, sizeof(hostname)) == SOCKET_ERROR) {
-		cout << "*** Error " << WSAGetLastError() << "getting local host name.\n";
+		std::cout << "*** Error " << WSAGetLastError() << "getting local host name.\n";
 		return 0;
 	}
 	// now get the host info for that host name
 	hostinfo = gethostbyname(hostname);
 	if (hostinfo == NULL) {
-		cout << "*** Error " << WSAGetLastError() << "getting host info for \"" << hostname << "\".\n";
+		std::cout << "*** Error " << WSAGetLastError() << "getting host info for \"" << hostname << "\".\n";
 		return 0;
 	}
 #ifdef _DEBUG
@@ -442,12 +442,12 @@
 		tcp_spec[count].type = TCPClientType;	// interface to access a client
 
 #ifdef _DEBUG
-		cout << "   Found " << tcp_spec[count].name << "." << endl;
+		std::cout << "   Found " << tcp_spec[count].name << "." << std::endl;
 #endif
 
 		if (++count >= MAX_NUM_INTERFACES) {
-			cout << "*** Found the maximum number of supported network interfaces: "
-			    << endl << "Only returning the first " << MAX_NUM_INTERFACES << "." << endl;
+			std::cout << "*** Found the maximum number of supported network interfaces: "
+			    << std::endl << "Only returning the first " << MAX_NUM_INTERFACES << "." << std::endl;
 			count = MAX_NUM_INTERFACES;
 			break;
 		}
@@ -455,7 +455,7 @@
 
 #if 0				// for debugging multiple-network-interface GUI; change "#if 0" to "#if 1" to enable
 	strncpy(nets[count], "foo", sizeof(nets[count]) - 1);
-	cout << "   Added fake entry " << nets[count] << "." << endl << flush;
+	std::cout << "   Added fake entry " << nets[count] << "." << std::endl << std::flush;
 	count++;
 #endif
 
@@ -462,13 +462,13 @@
 #if defined(IOMTR_OSFAMILY_WINDOWS)
 	// clean up WinSock
 	if (WSACleanup() != 0) {
-		cout << "*** Error " << WSAGetLastError() << "cleaning up WinSock." << endl;
+		std::cout << "*** Error " << WSAGetLastError() << "cleaning up WinSock." << std::endl;
 		return 0;
 	}
 #endif
 
 	// All done.
-	cout << "   done." << endl;
+	std::cout << "   done." << std::endl;
 	return count;
 }
 #endif
@@ -488,10 +488,10 @@
 	int vi_nic_name_no[KNOWN_VI_NIC_NAMES];
 	char env_var_name[MAX_NAME];
 
-	cout << "Reporting VI information..." << endl;
+	std::cout << "Reporting VI information..." << std::endl;
 	// Verify that VI is loaded on this system.
 	if (!vipl.vipl_dll) {
-		cout << "   VI library is not installed." << endl;
+		std::cout << "   VI library is not installed." << std::endl;
 		return 0;
 	}
 	// Initialize the base name and number for default VI nic names.
@@ -559,11 +559,11 @@
 			// Did the address fit, leaving enough room for the discriminator?
 			if (nic_address_size + min(VI_DISCRIMINATOR_SIZE, nic.nic_attributes.MaxDiscriminatorLen)
 			    > address_buffer_size) {
-				cout << "*** WARNING: VI NIC \"" << vi_spec[count].name
+				std::cout << "*** WARNING: VI NIC \"" << vi_spec[count].name
 				    << "\"'s address size (" << nic_address_size
 				    << ") + discriminator length (" << min(VI_DISCRIMINATOR_SIZE,
 									   nic.nic_attributes.MaxDiscriminatorLen)
-				    << ") is larger than address buffer size (" << address_buffer_size << ")!" << endl;
+				    << ") is larger than address buffer size (" << address_buffer_size << ")!" << std::endl;
 			}
 
 			vi_spec[count].vi_info.max_transfer_size = nic.nic_attributes.MaxTransferSize;
@@ -577,13 +577,13 @@
 
 			nic.Close();
 #ifdef _DEBUG
-			cout << "   Found " << vi_spec[count].name << "." << endl;
+			std::cout << "   Found " << vi_spec[count].name << "." << std::endl;
 #endif
 
 			// Prevent reporting more than the maximum number of VIs.
 			if (++count >= MAX_NUM_INTERFACES) {
-				cout << "*** Found the maximum number of supported VI interfaces: " << endl
-				    << "Only returning the first " << MAX_NUM_INTERFACES << "." << endl;
+				std::cout << "*** Found the maximum number of supported VI interfaces: " << std::endl
+				    << "Only returning the first " << MAX_NUM_INTERFACES << "." << std::endl;
 				return MAX_NUM_INTERFACES;
 			}
 		}
@@ -590,9 +590,9 @@
 	}
 
 	// All done.
-	cout << "   done." << endl;
+	std::cout << "   done." << std::endl;
 #ifdef _DEBUG
-	cout << "Find " << count << " network interface." << endl;
+	std::cout << "Find " << count << " network interface." << std::endl;
 #endif
 	return count;
 #else
@@ -728,7 +728,7 @@
 		// Only send results for grunts that are running.
 		if (grunts[g]->target_count && !grunts[g]->idle) {
 #ifdef _DEBUG
-			cout << "Reporting results for grunt " << g << " ...";
+			std::cout << "Reporting results for grunt " << g << " ...";
 #endif
 			// Copying worker's results into the message.
 			memcpy((void *)worker_results, (void *)&(grunts[g]->worker_performance),
@@ -807,7 +807,7 @@
 			}
 			prt->Send(&data_msg, DATA_MESSAGE_SIZE);
 #ifdef _DEBUG
-			cout << "sent." << endl;
+			std::cout << "sent." << std::endl;
 #endif
 		}
 	}
@@ -817,7 +817,7 @@
 		Get_Performance(LAST_UPDATE_PERF, FIRST_SNAPSHOT);
 	}
 #ifdef _DEBUG
-	cout << "   Finished reporting results." << endl;
+	std::cout << "   Finished reporting results." << std::endl;
 #endif
 }
 
@@ -830,11 +830,11 @@
 	while (TRUE)		// Receive loop.
 	{
 #ifdef _DEBUG
-		cout << "in while loop : Manager::Run() " << endl;
+		std::cout << "in while loop : Manager::Run() " << std::endl;
 #endif
 		if (prt->Receive(&msg) == PORT_ERROR) {
 			// Error receiving data message, stop running.
-			cout << "Error receiving message." << endl << flush;
+			std::cout << "Error receiving message." << std::endl << std::flush;
 			return FALSE;
 		} else {
 			if (IsBigEndian()) {
@@ -860,7 +860,7 @@
 	switch (msg.purpose) {
 	case ADD_WORKERS:
 #if _DETAILS
-		cout << "in Process_Message() : ADD_WORKERS" << endl;
+		std::cout << "in Process_Message() : ADD_WORKERS" << std::endl;
 #endif
 		Add_Workers(msg.data);
 		break;
@@ -869,7 +869,7 @@
 	case RESET:
 		// Remove all workers.
 #if _DETAILS
-		cout << "in Process_Message() : RESET" << endl;
+		std::cout << "in Process_Message() : RESET" << std::endl;
 #endif
 		Remove_Workers(ALL_WORKERS);
 		prt->Disconnect();
@@ -877,7 +877,7 @@
 		// Received call to end program or thread execution.
 	case EXIT:
 #if _DETAILS
-		cout << "in Process_Message() : EXIT" << endl;
+		std::cout << "in Process_Message() : EXIT" << std::endl;
 #endif
 		Remove_Workers(msg.data);
 		return (msg.data != MANAGER);
@@ -885,7 +885,7 @@
 		// Preparing drives for access.
 	case PREP_DISKS:
 #if _DETAILS
-		cout << "in Process_Message() : PREP_DISKS" << endl;
+		std::cout << "in Process_Message() : PREP_DISKS" << std::endl;
 #endif
 		Prepare_Disks(msg.data);
 		break;
@@ -893,7 +893,7 @@
 		// Signalling to stop disk preparation.
 	case STOP_PREPARE:
 #if _DETAILS
-		cout << "in Process_Message() : STOP_PREPARE" << endl;
+		std::cout << "in Process_Message() : STOP_PREPARE" << std::endl;
 #endif
 		Stop_Prepare(msg.data);
 		break;
@@ -901,7 +901,7 @@
 		// Reporting all targets accessible by this manager.
 	case REPORT_TARGETS:
 #if _DETAILS
-		cout << "in Process_Message() : REPORT_TARGETS" << endl;
+		std::cout << "in Process_Message() : REPORT_TARGETS" << std::endl;
 #endif
 		data_msg.count = Report_Disks(data_msg.data.targets);
 		if (IsBigEndian()) {
@@ -924,7 +924,7 @@
 		// Setting targets for a given grunt and reporting back.
 	case SET_TARGETS:
 #if _DETAILS
-		cout << "in Process_Message() : SET_TARGETS" << endl;
+		std::cout << "in Process_Message() : SET_TARGETS" << std::endl;
 #endif
 		prt->Receive(&data_msg, DATA_MESSAGE_SIZE);
 		if (IsBigEndian()) {
@@ -946,7 +946,7 @@
 		// Setting access specifications for next test.
 	case SET_ACCESS:
 #if _DETAILS
-		cout << "in Process_Message() : SET_ACCESS" << endl;
+		std::cout << "in Process_Message() : SET_ACCESS" << std::endl;
 #endif
 		prt->Receive(&data_msg, DATA_MESSAGE_SIZE);
 		if (IsBigEndian()) {
@@ -963,7 +963,7 @@
 		// Signalling start of test.
 	case START:
 #if _DETAILS
-		cout << "in Process_Message() : START" << endl;
+		std::cout << "in Process_Message() : START" << std::endl;
 #endif
 		Start_Test(msg.data);
 		break;
@@ -970,7 +970,7 @@
 		// Beginning to perform I/O.
 	case BEGIN_IO:
 #if _DETAILS
-		cout << "in Process_Message() : BEGIN_IO" << endl;
+		std::cout << "in Process_Message() : BEGIN_IO" << std::endl;
 #endif
 		Begin_IO(msg.data);
 		break;
@@ -977,7 +977,7 @@
 		// Beginning recording of test results.
 	case RECORD_ON:
 #if _DETAILS
-		cout << "in Process_Message() : RECORD_ON" << endl;
+		std::cout << "in Process_Message() : RECORD_ON" << std::endl;
 #endif
 		Record_On(msg.data);
 		break;
@@ -984,7 +984,7 @@
 		// Stopping recording of test results.
 	case RECORD_OFF:
 #if _DETAILS
-		cout << "in Process_Message() : RECORD_OFF" << endl;
+		std::cout << "in Process_Message() : RECORD_OFF" << std::endl;
 #endif
 		Record_Off(msg.data);
 		break;
@@ -991,7 +991,7 @@
 		// Signalling to stop testing.
 	case STOP:
 #if _DETAILS
-		cout << "in Process_Message() : STOP" << endl;
+		std::cout << "in Process_Message() : STOP" << std::endl;
 #endif
 		Stop_Test(msg.data);
 		break;
@@ -999,7 +999,7 @@
 		// Reporting results of whole test to Iometer.
 	case REPORT_RESULTS:
 #if _DETAILS
-		cout << "in Process_Message() : REPORT_RESULTS" << endl;
+		std::cout << "in Process_Message() : REPORT_RESULTS" << std::endl;
 #endif
 		Report_Results(WHOLE_TEST_PERF);
 		break;
@@ -1007,13 +1007,13 @@
 		// Reporting results since last update to Iometer.
 	case REPORT_UPDATE:
 #if _DETAILS
-		cout << "in Process_Message() : REPORT_UPDATE" << endl;
+		std::cout << "in Process_Message() : REPORT_UPDATE" << std::endl;
 #endif
 		Report_Results(LAST_UPDATE_PERF);
 		break;
 
 	default:
-		cout << "*** Unknown purpose found in message." << endl << flush;
+		std::cout << "*** Unknown purpose found in message." << std::endl << std::flush;
 		return FALSE;
 	}
 	return TRUE;
@@ -1034,7 +1034,7 @@
 		GenerateRandomData();
 	}
 
-	cout << "Starting..." << endl << flush;
+	std::cout << "Starting..." << std::endl << std::flush;
 
 	// Start all the grunts.  This creates the grunt threads.
 	// Pass as argument the index of the Target. Can be used for affinity.
@@ -1046,7 +1046,7 @@
 		grunts[target]->Start_Test(target);
 	}
 #ifdef _DEBUG
-	cout << "   Started." << endl << flush;
+	std::cout << "   Started." << std::endl << std::flush;
 #endif
 	// Reply that test has started.
 	msg.data = TRUE;
@@ -1055,7 +1055,7 @@
 
 void Manager::GenerateRandomData() 
 {
-	cout << "   Generating random data..." << endl;
+	std::cout << "   Generating random data..." << std::endl;
 
 	//Find the first grunt with a target and use the spec.random from it to seed the PRNG
 	DWORDLONG SeedVal;
@@ -1068,12 +1068,12 @@
 			if(grunts[i]->Need_Random_Buffer()) 
 			{
 				SeedVal = grunts[i]->Get_Target_Spec_Random_Value(0);
-				cout << "   Seeding Random Data Random Number Generator from Target Spec to:" << (unsigned int)SeedVal << endl;
+				std::cout << "   Seeding Random Data Random Number Generator from Target Spec to:" << (unsigned int)SeedVal << std::endl;
 
-				map<DWORDLONG,unsigned char*>::iterator it = randomDataBuffers.find(SeedVal);
+				std::map<DWORDLONG,unsigned char*>::iterator it = randomDataBuffers.find(SeedVal);
 				if(it != randomDataBuffers.end()) 
 				{
-					cout << "   Using existing random data." << endl;
+					std::cout << "   Using existing random data." << std::endl;
 					grunts[i]->Set_Random_Data_Buffer(randomDataBuffers[SeedVal], RANDOM_BUFFER_SIZE);
 				} 
 				else 
@@ -1108,12 +1108,12 @@
 							randomDataBuffers[SeedVal][x] = (unsigned char)rand();
 
 						grunts[i]->Set_Random_Data_Buffer(randomDataBuffers[SeedVal], RANDOM_BUFFER_SIZE);
-						cout << "   Done generating random data." << endl;
+						std::cout << "   Done generating random data." << std::endl;
 					} 
 					else 
 					{
 						// Could not allocate a larger buffer.  Signal failure.
-						cout << "   Error allocating random data buffer..." << endl;
+						std::cout << "   Error allocating random data buffer..." << std::endl;
 					}
 
 				}
@@ -1129,7 +1129,7 @@
 {
 	if (!randomDataBuffers.empty())
 	{
-		map<DWORDLONG,unsigned char*>::iterator it;
+		std::map<DWORDLONG,unsigned char*>::iterator it;
 
 		for ( it=randomDataBuffers.begin() ; it != randomDataBuffers.end(); it++ )
 		{
@@ -1157,7 +1157,7 @@
 void Manager::Begin_IO(int target)
 {
 	msg.data = TRUE;
-	cout << "Beginning to perform I/O..." << endl << flush;
+	std::cout << "Beginning to perform I/O..." << std::endl << std::flush;
 
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_SOLARIS)
 	if (do_syslog) {
@@ -1177,7 +1177,7 @@
 			msg.data = FALSE;
 	}
 #ifdef _DEBUG
-	cout << "   Performing I/O." << endl << flush;
+	std::cout << "   Performing I/O." << std::endl << std::flush;
 #endif
 
 	// Reply that I/O has started.
@@ -1202,7 +1202,7 @@
 		grunts[target]->Stop_Test();
 	}
 
-	cout << "Stopping..." << endl << flush;
+	std::cout << "Stopping..." << std::endl << std::flush;
 
 	if (target == ALL_WORKERS) {
 		for (int i = 0; i < grunt_count; i++) {
@@ -1212,7 +1212,7 @@
 		grunts[target]->Wait_For_Stop();
 	}
 
-	cout << "   Stopped." << endl << flush;
+	std::cout << "   Stopped." << std::endl << std::flush;
 
 	// Reply that test has stopped.
 	if (IsBigEndian()) {
@@ -1232,7 +1232,7 @@
 //
 void Manager::Stop_Prepare(int target)
 {
-	cout << "Stopping..." << endl << flush;
+	std::cout << "Stopping..." << std::endl << std::flush;
 
 	if (target == ALL_WORKERS)
 		for (int i = 0; i < grunt_count; i++)
@@ -1240,7 +1240,7 @@
 	else
 		grunts[target]->grunt_state = TestIdle;
 
-	cout << "   Stopped." << endl << flush;
+	std::cout << "   Stopped." << std::endl << std::flush;
 }
 
 //
@@ -1251,13 +1251,13 @@
 	// If we're removing just one worker, remove it and return.
 	if (target >= 0 && target < grunt_count) {
 		// Remove a worker.  It does not matter which one.
-		cout << "Removing worker " << target << "." << endl << flush;
+		std::cout << "Removing worker " << target << "." << std::endl << std::flush;
 		delete grunts[--grunt_count];
 
 		return;
 	}
 	// Remove all workers.
-	cout << "Removing all workers." << endl << flush;
+	std::cout << "Removing all workers." << std::endl << std::flush;
 	while (grunt_count)
 		delete grunts[--grunt_count];
 }
@@ -1269,12 +1269,12 @@
 {
 	if (worker_no == ALL_WORKERS) {
 		for (int i = 0; i < grunt_count; i++) {
-			cout << "Worker " << i << " setting targets..." << endl;
+			std::cout << "Worker " << i << " setting targets..." << std::endl;
 			if (!grunts[i]->Set_Targets(count, target_specs))
 				return FALSE;
 		}
 	} else {
-		cout << "Worker " << worker_no << " setting targets..." << endl;
+		std::cout << "Worker " << worker_no << " setting targets..." << std::endl;
 		return grunts[worker_no]->Set_Targets(count, target_specs);
 	}
 	return TRUE;
@@ -1294,7 +1294,7 @@
 
 	// Recursively assign all workers the same access specification.
 	if (target == ALL_WORKERS) {
-		cout << "All workers running Access Spec: " << spec->name << endl;
+		std::cout << "All workers running Access Spec: " << spec->name << std::endl;
 		for (g = 0; g < grunt_count; g++) {
 			if (!Set_Access(g, spec))
 				return FALSE;
@@ -1302,7 +1302,7 @@
 		return TRUE;
 	}
 
-	cout << "Worker " << target << " running Access Spec: " << spec->name << endl;
+	std::cout << "Worker " << target << " running Access Spec: " << spec->name << std::endl;
 
 	// If the grunt could not set the access spec properly, return.
 	// The grunt may not have been able to grow its data buffer.
@@ -1316,8 +1316,8 @@
 	}
 	// Grow the manager's data buffer and update all grunts using it.
 #ifdef _DEBUG
-	cout << "Growing manager data buffer from " << data_size << " to "
-	    << grunts[target]->access_spec.max_transfer << endl << flush;
+	std::cout << "Growing manager data buffer from " << data_size << " to "
+	    << grunts[target]->access_spec.max_transfer << std::endl << std::flush;
 #endif
 
 	// Align all data transfers on a page boundary.  This will work for all disks
@@ -1339,7 +1339,7 @@
 #endif
 	{
 		// Could not allocate a larger buffer.  Signal failure.
-		cout << "*** Manager could not allocate data buffer for I/O transfers." << endl << flush;
+		std::cout << "*** Manager could not allocate data buffer for I/O transfers." << std::endl << std::flush;
 		data_size = 0;
 		return FALSE;
 	}
@@ -1364,7 +1364,7 @@
 	record = TRUE;		// At least 1 worker is recording.
 
 #ifdef _DEBUG
-	cout << "Recording Started." << endl << flush;
+	std::cout << "Recording Started." << std::endl << std::flush;
 #endif
 
 	if (target == ALL_WORKERS) {
@@ -1396,11 +1396,11 @@
 	} else {
 		grunts[target]->Record_Off();
 	}
-	cout << "   Stopped." << endl << flush;
+	std::cout << "   Stopped." << std::endl << std::flush;
 
 	record = FALSE;		// No workers are recording data.
 #ifdef _DEBUG
-	cout << "Recording stopped." << endl << flush;
+	std::cout << "Recording stopped." << std::endl << std::flush;
 #endif
 	if (IsBigEndian()) {
 		(void)reorder(msg);
@@ -1417,7 +1417,7 @@
 	msg.data = 0;
 
 #ifdef _DEBUG
-	cout << "Adding " << count << " new worker(s)." << endl << flush;
+	std::cout << "Adding " << count << " new worker(s)." << std::endl << std::flush;
 #endif
 
 	for (int i = 0; i < count; i++) {
@@ -1441,7 +1441,7 @@
 		}
 	}
 #ifdef _DEBUG
-	cout << msg.data << " worker(s) are created." << endl;
+	std::cout << msg.data << " worker(s) are created." << std::endl;
 #endif
 
 	if (IsBigEndian()) {
--- iometer-1.1.0-rc1/src/IOTime.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOTime.cpp	Mon Aug 20 18:18:46 2012
@@ -346,8 +346,8 @@
 	if (!QueryPerformanceCounter(&perf_count))
 	{
 #if _DETAILS
-		cerr << "QueryPerformanceCounter failed with error " << GetLastError() << 
-			    ", dynamo results are invalid." << endl;
+		std::cerr << "QueryPerformanceCounter failed with error " << GetLastError() << 
+			    ", dynamo results are invalid." << std::endl;
 #endif
 		return 1;
 	}
@@ -362,8 +362,8 @@
 	if (!QueryPerformanceFrequency(&perf_freq))
 	{
 #if _DETAILS
-		cerr << "QueryPeformanceFrequency failed with error " << GetLastError() << 
-			    ", dynamo results are invalid." << endl;
+		std::cerr << "QueryPeformanceFrequency failed with error " << GetLastError() << 
+			    ", dynamo results are invalid." << std::endl;
 #endif 
 		return 1;
 	}
@@ -458,9 +458,9 @@
 #if _DEBUG
 	if (info.denom != 1 || info.numer != 1)
 	{
-		cout << "Warning: mach_timebase_info() has reported non-1 values --"
+		std::cout << "Warning: mach_timebase_info() has reported non-1 values --"
 			 << "contact the IOmeter team, numerator: " << info.numer 
-			 << " denominator: " << info.denom << "." << endl;
+			 << " denominator: " << info.denom << "." << std::endl;
 	}
 #endif
 	return ((double) info.denom * 1e9 / info.numer);
@@ -564,13 +564,13 @@
 	if (perf_freq != 1)
 	{
 #if _DETAILS
-		cout << "Performance counter frequency: " << (perf_freq / 1000000.00) << "MHz." << endl;
+		std::cout << "Performance counter frequency: " << (perf_freq / 1000000.00) << "MHz." << std::endl;
 #endif
 	}
 	else 
 	{
 		// Should never really get here.
-		cerr << "Could not query performance frequency, exiting." << endl;
+		std::cerr << "Could not query performance frequency, exiting." << std::endl;
 		exit(1); 
 	}
 
@@ -611,17 +611,17 @@
 		         max(new_freq[SLEEP_CASE], new_freq[SPIN_CASE]) > 5.0)
 	{
 
-		cout << "##########################################################################" << endl;
-		cout << " Detected speed-stepping CPU. Disable power saving mode when using IOmeter." << endl;
-		cout << "##########################################################################" << endl;
+		std::cout << "##########################################################################" << std::endl;
+		std::cout << " Detected speed-stepping CPU. Disable power saving mode when using IOmeter." << std::endl;
+		std::cout << "##########################################################################" << std::endl;
 
 #if _DEBUG
-		cout << " Measured spin freq: " << new_freq[SPIN_CASE]/1000000 << 
-			    "MHz, sleep freq: " <<  new_freq[SLEEP_CASE]/1000000 << "MHz. " << endl;
+		std::cout << " Measured spin freq: " << new_freq[SPIN_CASE]/1000000 << 
+			    "MHz, sleep freq: " <<  new_freq[SLEEP_CASE]/1000000 << "MHz. " << std::endl;
 #endif
 
 		// Fallback to OSHPC?
-		cout << " Reverting to performance counter with frequency: " << (perf_freq / 1000000.00) << "MHz." << endl;
+		std::cout << " Reverting to performance counter with frequency: " << (perf_freq / 1000000.00) << "MHz." << std::endl;
 
 		TimerType = TIMER_OSHPC;
 		frequency = perf_freq; 
@@ -631,13 +631,13 @@
 				   max(new_freq[SPIN_CASE], perf_freq) > 5.0)
 	{
 		// if it's not close, we use the new spin frequency
-		cout << " Using RDTSC frequency: " << (new_freq[0] / 1000000.00) << "MHz." << endl;
+		std::cout << " Using RDTSC frequency: " << (new_freq[0] / 1000000.00) << "MHz." << std::endl;
 		frequency = new_freq[SPIN_CASE];
 	}
 	else
 	{
 		// if it's close, lets trust the original perf frequency
-		cout << " Measured frequency matches performance counter frequency, using latter: " << (perf_freq / 1000000.00) << "MHz." << endl;
+		std::cout << " Measured frequency matches performance counter frequency, using latter: " << (perf_freq / 1000000.00) << "MHz." << std::endl;
 		frequency = perf_freq;
 	}
 
@@ -680,10 +680,10 @@
 			if (timerFreq == 1.0)
 			{
 				// This call really has to work!
-				cerr << "Could not obtain peformance frequency, exiting." << endl;
+				std::cerr << "Could not obtain peformance frequency, exiting." << std::endl;
 				exit(1);
 			}
-			cout << " Using performance counter frequency: " << (timerFreq / 1000000.00) << "MHz." << endl;
+			std::cout << " Using performance counter frequency: " << (timerFreq / 1000000.00) << "MHz." << std::endl;
 			break;
     }
 
--- iometer-1.1.0-rc1/src/IOTargetVI.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOTargetVI.cpp	Mon Aug 20 18:18:46 2012
@@ -114,12 +114,12 @@
 BOOL TargetVI::Initialize(Target_Spec * target_info, CQ * completion_queue)
 {
 #ifdef _DEBUG
-	cout << "Initializing VI target on NIC " << target_info->name << endl;
+	std::cout << "Initializing VI target on NIC " << target_info->name << std::endl;
 #endif
 
 	// Open the VI NIC.
 	if (!vi_nic.Open(target_info->name)) {
-		cout << "*** VI target unable to open VI NIC." << endl;
+		std::cout << "*** VI target unable to open VI NIC." << std::endl;
 		return FALSE;
 	}
 	// Allocate I/O descriptors for VI requests and align them on a page
@@ -149,7 +149,7 @@
 #endif
 	{
 		// Could not allocate descriptors.  Signal failure.
-		cout << "*** VI target could not allocate memory for descriptors." << endl;
+		std::cout << "*** VI target could not allocate memory for descriptors." << std::endl;
 		descriptors = NULL;
 		descriptor_count = 0;
 		send_count = 0;
@@ -159,7 +159,7 @@
 
 	// Register descriptors with VI NIC.
 	if (!vi_nic.RegisterMemory(descriptors, descriptor_count * sizeof(VIP_DESCRIPTOR), &descriptor_handle)) {
-		cout << "*** VI target unable to register descriptors with VI NIC." << endl;
+		std::cout << "*** VI target unable to register descriptors with VI NIC." << std::endl;
 		return FALSE;
 	}
 	// Allocate descriptors for sends and receives.
@@ -180,7 +180,7 @@
 
 	// Register data buffer with VI NIC.
 	if (!vi_nic.RegisterMemory(data_buffer, data_buffer_size, &data_buffer_handle)) {
-		cout << "*** Unable to register data buffer with VI NIC." << endl;
+		std::cout << "*** Unable to register data buffer with VI NIC." << std::endl;
 		return FALSE;
 	}
 	// Return a pointer to the VI completion queue used by this VI connection.
@@ -196,12 +196,12 @@
 		// wait on the client.
 		lastIO = READ;
 #if TARGETVI_DETAILS
-		cout << "Initialized VI server." << endl;
+		std::cout << "Initialized VI server." << std::endl;
 #endif
 	} else {
 		lastIO = WRITE;
 #if TARGETVI_DETAILS
-		cout << "Initialized VI client." << endl;
+		std::cout << "Initialized VI client." << std::endl;
 #endif
 	}
 
@@ -230,7 +230,7 @@
 	next_recv_index = 0;
 
 	if (vi.Create(&vi_nic, this) != ReturnSuccess) {
-		cout << "*** Unable to create VI on opened nic." << endl;
+		std::cout << "*** Unable to create VI on opened nic." << std::endl;
 		return FALSE;
 	}
 	// Pre-post enough receives to ensure remote side can send immediately
@@ -237,7 +237,7 @@
 	// after making the connection.
 	for (i = 0; i < recv_count; i++) {
 		if (PostRecv() != ReturnSuccess) {
-			cout << "*** Unable to pre-post receives while opening VI." << endl;
+			std::cout << "*** Unable to pre-post receives while opening VI." << std::endl;
 			return FALSE;
 		}
 	}
@@ -245,45 +245,45 @@
 #if TARGETVI_DETAILS
 	int ii;
 
-	cout << "In TargetVI::Open():" << endl;
-	cout << "    is_server = " << is_server << endl;
+	std::cout << "In TargetVI::Open():" << std::endl;
+	std::cout << "    is_server = " << is_server << std::endl;
 
-	cout << "    spec.vi_info.local_address.HostAddressLen = " << spec.vi_info.local_address.HostAddressLen << endl;
-	cout << "    spec.vi_info.local_address.HostAddress[0.." << spec.vi_info.local_address.HostAddressLen -
+	std::cout << "    spec.vi_info.local_address.HostAddressLen = " << spec.vi_info.local_address.HostAddressLen << std::endl;
+	std::cout << "    spec.vi_info.local_address.HostAddress[0.." << spec.vi_info.local_address.HostAddressLen -
 	    1 << "] = ";
 	for (ii = 0; ii < spec.vi_info.local_address.HostAddressLen; ii++) {
-		cout << hex << (int)spec.vi_info.local_address.HostAddress[ii] << dec << " ";
+		std::cout << hex << (int)spec.vi_info.local_address.HostAddress[ii] << dec << " ";
 	}
-	cout << endl;
-	cout << "    spec.vi_info.local_address.DiscriminatorLen = " << spec.vi_info.local_address.
-	    DiscriminatorLen << endl;
-	cout << "    spec.vi_info.local_address.HostAddress[" << spec.vi_info.local_address.
+	std::cout << std::endl;
+	std::cout << "    spec.vi_info.local_address.DiscriminatorLen = " << spec.vi_info.local_address.
+	    DiscriminatorLen << std::endl;
+	std::cout << "    spec.vi_info.local_address.HostAddress[" << spec.vi_info.local_address.
 	    HostAddressLen << ".." << spec.vi_info.local_address.HostAddressLen +
 	    spec.vi_info.local_address.DiscriminatorLen - 1 << "] = ";
 	for (ii = spec.vi_info.local_address.HostAddressLen;
 	     ii < spec.vi_info.local_address.HostAddressLen + spec.vi_info.local_address.DiscriminatorLen; ii++) {
-		cout << hex << (int)spec.vi_info.local_address.HostAddress[ii] << dec << " ";
+		std::cout << hex << (int)spec.vi_info.local_address.HostAddress[ii] << dec << " ";
 	}
-	cout << endl;
+	std::cout << std::endl;
 
-	cout << "    spec.vi_info.remote_address.HostAddressLen = " << spec.vi_info.remote_address.
-	    HostAddressLen << endl;
-	cout << "    spec.vi_info.remote_address.HostAddress[0.." << spec.vi_info.remote_address.HostAddressLen -
+	std::cout << "    spec.vi_info.remote_address.HostAddressLen = " << spec.vi_info.remote_address.
+	    HostAddressLen << std::endl;
+	std::cout << "    spec.vi_info.remote_address.HostAddress[0.." << spec.vi_info.remote_address.HostAddressLen -
 	    1 << "] = ";
 	for (ii = 0; ii < spec.vi_info.remote_address.HostAddressLen; ii++) {
-		cout << hex << (int)spec.vi_info.remote_address.HostAddress[ii] << dec << " ";
+		std::cout << hex << (int)spec.vi_info.remote_address.HostAddress[ii] << dec << " ";
 	}
-	cout << endl;
-	cout << "    spec.vi_info.remote_address.DiscriminatorLen = " << spec.vi_info.remote_address.
-	    DiscriminatorLen << endl;
-	cout << "    spec.vi_info.remote_address.HostAddress[" << spec.vi_info.remote_address.
+	std::cout << std::endl;
+	std::cout << "    spec.vi_info.remote_address.DiscriminatorLen = " << spec.vi_info.remote_address.
+	    DiscriminatorLen << std::endl;
+	std::cout << "    spec.vi_info.remote_address.HostAddress[" << spec.vi_info.remote_address.
 	    HostAddressLen << ".." << spec.vi_info.remote_address.HostAddressLen +
 	    spec.vi_info.remote_address.DiscriminatorLen - 1 << "] = ";
 	for (ii = spec.vi_info.remote_address.HostAddressLen;
 	     ii < spec.vi_info.remote_address.HostAddressLen + spec.vi_info.remote_address.DiscriminatorLen; ii++) {
-		cout << hex << (int)spec.vi_info.remote_address.HostAddress[ii] << dec << " ";
+		std::cout << hex << (int)spec.vi_info.remote_address.HostAddress[ii] << dec << " ";
 	}
-	cout << endl;
+	std::cout << std::endl;
 #endif
 
 	// Open VI connection depending on whether this is the client or server
@@ -296,7 +296,7 @@
 		} while (result == ReturnRetry && *test_state != TestIdle);
 
 		if (result == ReturnError) {
-			cout << "*** Unable to accept connection opening VI target." << endl;
+			std::cout << "*** Unable to accept connection opening VI target." << std::endl;
 			return FALSE;
 		}
 	} else {
@@ -306,7 +306,7 @@
 		} while (result == ReturnRetry && *test_state != TestIdle);
 
 		if (result == ReturnError) {
-			cout << "*** Unable to connect to server opening VI target." << endl;
+			std::cout << "*** Unable to connect to server opening VI target." << std::endl;
 			return FALSE;
 		}
 	}
@@ -348,7 +348,7 @@
 {
 	lastIO = READ;
 #if TARGETVI_DETAILS
-	cout << "Performing I/O read request for transaction " << trans->request_number << endl;
+	std::cout << "Performing I/O read request for transaction " << trans->request_number << std::endl;
 #endif
 
 	// If any receives are available, pre-post one.
@@ -355,7 +355,7 @@
 	if (available_receives) {
 		// Posting an additional receive.
 		if (PostRecv() != ReturnSuccess) {
-			cout << "*** Failed to pre-post a receive over VI." << endl;
+			std::cout << "*** Failed to pre-post a receive over VI." << std::endl;
 			return ReturnError;
 		}
 		available_receives--;
@@ -364,7 +364,7 @@
 		// additional receives.
 		if (--control_countdown <= 0) {
 			if (SendControl() != ReturnSuccess) {
-				cout << "*** Failed to send control message over VI." << endl;
+				std::cout << "*** Failed to send control message over VI." << std::endl;
 				return ReturnError;
 			}
 			control_countdown = control_countdown_start;
@@ -381,7 +381,7 @@
 		// queue.  Return immediate success to signal that the I/O should be
 		// processed immediately and will not appear in the completion queue.
 #if TARGETVI_DETAILS
-		cout << "Receive was already done." << endl;
+		std::cout << "Receive was already done." << std::endl;
 #endif
 		return ReturnSuccess;
 	}
@@ -425,7 +425,7 @@
 
 	if (vi.Receive(&recv_descriptors[next_recv_index], descriptor_handle)
 	    != ReturnSuccess) {
-		cout << "*** Failed to post a receive for VI connection." << endl;
+		std::cout << "*** Failed to post a receive for VI connection." << std::endl;
 		return ReturnError;
 	}
 	// Receives complete in the order posted, so update index of next one
@@ -443,7 +443,7 @@
 {
 	lastIO = WRITE;
 #if TARGETVI_DETAILS
-	cout << "Performing I/O write request for transaction " << trans->request_number << endl;
+	std::cout << "Performing I/O write request for transaction " << trans->request_number << std::endl;
 #endif
 
 	// Check to see if the completion queue has marked that more sends are
@@ -450,7 +450,7 @@
 	// available for requesting.
 	if (more_sends_available) {
 #if TARGETVI_DETAILS
-		cout << "Updating number of sends available." << endl;
+		std::cout << "Updating number of sends available." << std::endl;
 #endif
 
 		more_sends_available = FALSE;
@@ -458,7 +458,7 @@
 
 		// We need to repost the receive needed for control flow.
 		if (PostRecv() != ReturnSuccess) {
-			cout << "*** Unable to post send for control flow." << endl;
+			std::cout << "*** Unable to post send for control flow." << std::endl;
 			return ReturnError;
 		}
 	}
@@ -466,7 +466,7 @@
 	// receive.  Checking to make sure that remote side is ready.
 	if (!available_sends) {
 #if TARGETVI_DETAILS
-		cout << "No sends are available." << endl;
+		std::cout << "No sends are available." << std::endl;
 #endif
 
 		// Remote side is not ready.  Abort the operation to signal that the
@@ -490,7 +490,7 @@
 
 	if (vi.Send(&send_descriptors[next_send_index], descriptor_handle)
 	    != ReturnSuccess) {
-		cout << "*** VI send failed to remote VI target." << endl;
+		std::cout << "*** VI send failed to remote VI target." << std::endl;
 		return ReturnError;
 	}
 	// Sends complete in the order posted, so update index of next
@@ -521,12 +521,12 @@
 	send_descriptors[next_send_index].DS[0].Local.Length = 0;
 
 #if TARGETVI_DETAILS
-	cout << "Sending control message to remote VI connection." << endl;
+	std::cout << "Sending control message to remote VI connection." << std::endl;
 #endif
 
 	if (vi.Send(&send_descriptors[next_send_index], descriptor_handle)
 	    != ReturnSuccess) {
-		cout << "*** Failed to send VI control message." << endl;
+		std::cout << "*** Failed to send VI control message." << std::endl;
 		return ReturnError;
 	}
 	// Sends complete in the order posted, so update index of next
--- iometer-1.1.0-rc1/src/ByteOrder.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/ByteOrder.cpp	Mon Aug 20 18:18:45 2012
@@ -89,12 +89,12 @@
 {
 	if (!res)
 		return;
-	cout << " CPU Counters:";
-	cout << "   " << res->CPU_utilization[0][CPU_TOTAL_UTILIZATION];
-	cout << "   " << res->CPU_utilization[0][CPU_USER_UTILIZATION];
-	cout << "   " << res->CPU_utilization[0][CPU_PRIVILEGED_UTILIZATION];
-	cout << "   " << res->CPU_utilization[0][CPU_IRQ];
-	cout << endl;
+	std::cout << " CPU Counters:";
+	std::cout << "   " << res->CPU_utilization[0][CPU_TOTAL_UTILIZATION];
+	std::cout << "   " << res->CPU_utilization[0][CPU_USER_UTILIZATION];
+	std::cout << "   " << res->CPU_utilization[0][CPU_PRIVILEGED_UTILIZATION];
+	std::cout << "   " << res->CPU_utilization[0][CPU_IRQ];
+	std::cout << std::endl;
 }
 
 void Dump_Net_Results(struct Net_Results *res)
@@ -101,12 +101,12 @@
 {
 	if (!res)
 		return;
-	cout << " Net Counters:";
-	cout << "   " << res->tcp_stats[TCP_SEGMENTS_RESENT];
-	cout << "   " << res->ni_stats[0][NI_PACKETS];
-	cout << "   " << res->ni_stats[0][NI_OUT_ERRORS];
-	cout << "   " << res->ni_stats[0][NI_IN_ERRORS];
-	cout << endl;
+	std::cout << " Net Counters:";
+	std::cout << "   " << res->tcp_stats[TCP_SEGMENTS_RESENT];
+	std::cout << "   " << res->ni_stats[0][NI_PACKETS];
+	std::cout << "   " << res->ni_stats[0][NI_OUT_ERRORS];
+	std::cout << "   " << res->ni_stats[0][NI_IN_ERRORS];
+	std::cout << std::endl;
 }
 
 void Dump_Manager_Results(struct Manager_Results *res)
@@ -113,8 +113,8 @@
 {
 	if (!res)
 		return;
-	cout << "Dump manager result: " << endl;
-	cout << " time_counter = " << res->time_counter << endl;
+	std::cout << "Dump manager result: " << std::endl;
+	std::cout << " time_counter = " << res->time_counter << std::endl;
 	Dump_CPU_Results(&(res->cpu_results));
 	Dump_Net_Results(&(res->net_results));
 }
@@ -123,25 +123,25 @@
 {
 	if (!res)
 		return;
-	cout << "Dump raw result: " << endl;
-	cout << "   " << "bytes_read =" << res->bytes_read << endl;
-	cout << "   " << "bytes_written =" << res->bytes_written << endl;
-	cout << "   " << "read_count =" << res->read_count << endl;
-	cout << "   " << "write_count =" << res->write_count << endl;
-	cout << "   " << "transaction_count =" << res->transaction_count << endl;
-	cout << "   " << "connection_count =" << res->connection_count << endl;
-	cout << "   " << "read_errors =" << res->read_errors << endl;
-	cout << "   " << "write_errors =" << res->write_errors << endl;
-	cout << "   " << "max_raw_read_latency =" << res->max_raw_read_latency << endl;
-	cout << "   " << "read_latency_sum =" << res->read_latency_sum << endl;
-	cout << "   " << "max_raw_write_latency =" << res->max_raw_write_latency << endl;
-	cout << "   " << "write_latency_sum =" << res->write_latency_sum << endl;
-	cout << "   " << "max_raw_transaction_latency =" << res->max_raw_transaction_latency << endl;
-	cout << "   " << "max_raw_connection_latency =" << res->max_raw_connection_latency << endl;
-	cout << "   " << "transaction_latency_sum =" << res->transaction_latency_sum << endl;
-	cout << "   " << "connection_latency_sum =" << res->connection_latency_sum << endl;
-	cout << "   " << "counter_time =" << res->counter_time << endl;
-	cout << "Dump raw result end. " << endl;
+	std::cout << "Dump raw result: " << std::endl;
+	std::cout << "   " << "bytes_read =" << res->bytes_read << std::endl;
+	std::cout << "   " << "bytes_written =" << res->bytes_written << std::endl;
+	std::cout << "   " << "read_count =" << res->read_count << std::endl;
+	std::cout << "   " << "write_count =" << res->write_count << std::endl;
+	std::cout << "   " << "transaction_count =" << res->transaction_count << std::endl;
+	std::cout << "   " << "connection_count =" << res->connection_count << std::endl;
+	std::cout << "   " << "read_errors =" << res->read_errors << std::endl;
+	std::cout << "   " << "write_errors =" << res->write_errors << std::endl;
+	std::cout << "   " << "max_raw_read_latency =" << res->max_raw_read_latency << std::endl;
+	std::cout << "   " << "read_latency_sum =" << res->read_latency_sum << std::endl;
+	std::cout << "   " << "max_raw_write_latency =" << res->max_raw_write_latency << std::endl;
+	std::cout << "   " << "write_latency_sum =" << res->write_latency_sum << std::endl;
+	std::cout << "   " << "max_raw_transaction_latency =" << res->max_raw_transaction_latency << std::endl;
+	std::cout << "   " << "max_raw_connection_latency =" << res->max_raw_connection_latency << std::endl;
+	std::cout << "   " << "transaction_latency_sum =" << res->transaction_latency_sum << std::endl;
+	std::cout << "   " << "connection_latency_sum =" << res->connection_latency_sum << std::endl;
+	std::cout << "   " << "counter_time =" << res->counter_time << std::endl;
+	std::cout << "Dump raw result end. " << std::endl;
 }
 #endif
 
@@ -318,7 +318,7 @@
 	case DATA_MESSAGE_MANAGER_INFO:
 		// struct Manager_Info
 #ifdef _DEBUG
-		cout << "Manager_Info count: " << var.count << endl;
+		std::cout << "Manager_Info count: " << var.count << std::endl;
 #endif
 		reorder(var.data.manager_info.port_number);
 		reorder(var.data.manager_info.processors);
@@ -328,7 +328,7 @@
 	case DATA_MESSAGE_TARGET_SPEC:
 		// struct Target_Spec
 #ifdef _DEBUG
-		cout << "Target_Spec count: " << var.count << endl;
+		std::cout << "Target_Spec count: " << var.count << std::endl;
 #endif
 		for (i = 0; i < var.count; i++) {
 			// must be first after recv.
@@ -352,7 +352,7 @@
 
 			if (IsType(var.data.targets[i].type, GenericVIType)) {
 #ifdef _DEBUG
-				cerr << "WARNING: VI data marshalling not supported yet." << endl;
+				std::cerr << "WARNING: VI data marshalling not supported yet." << std::endl;
 #endif
 			}
 			// Now re-order the other stuff.
@@ -373,7 +373,7 @@
 	case DATA_MESSAGE_TEST_SPEC:
 		// struct Test_Spec
 #ifdef _DEBUG
-		cout << "Test_Spec count: " << var.count << endl;
+		std::cout << "Test_Spec count: " << var.count << std::endl;
 #endif
 		reorder(var.data.spec.default_assignment);
 		for (i = 0; i < MAX_ACCESS_SPECS; i++) {
@@ -391,7 +391,7 @@
 	case DATA_MESSAGE_MANAGER_RESULTS:
 		// Manager Results processed here.
 #ifdef _DEBUG
-		cout << "Test_Spec count: " << var.count << endl;
+		std::cout << "Test_Spec count: " << var.count << std::endl;
 #endif
 		for (i = 0; i < MAX_SNAPSHOTS; i++)
 			reorder(var.data.manager_results.time_counter[i]);
@@ -403,7 +403,7 @@
 	case DATA_MESSAGE_WORKER_RESULTS:
 		// Worker Results processed here.
 #ifdef _DEBUG
-		cout << "Test_Spec count: " << var.count << endl;
+		std::cout << "Test_Spec count: " << var.count << std::endl;
 #endif
 		for (i = 0; i < MAX_SNAPSHOTS; i++)
 			reorder(var.data.worker_results.time[i]);
No differences encountered
No differences encountered
--- iometer-1.1.0-rc1/src/IOCQVI.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOCQVI.cpp	Mon Aug 20 18:18:45 2012
@@ -91,13 +91,13 @@
 	VIP_RETURN result;
 
 #if CQVI_DETAILS
-	cout << "Creating VI CQ for VI NIC " << vi_nic->nic_attributes.Name << endl;
+	std::cout << "Creating VI CQ for VI NIC " << vi_nic->nic_attributes.Name << std::endl;
 #endif
 
 	// Create a completion queue for the NIC.  The completion queue must be
 	// able to handle the specified number of oustanding I/Os.
 	if ((result = vipl.VipCreateCQ(vi_nic->nic, target->outstanding_ios, &completion_queue)) != VIP_SUCCESS) {
-		cout << "*** Unable to create VI completion queue: " << vipl.Error(result) << endl;
+		std::cout << "*** Unable to create VI completion queue: " << vipl.Error(result) << std::endl;
 		return FALSE;
 	}
 	// Record which target this completion is associated with.
@@ -114,7 +114,7 @@
 	VIP_RETURN result;
 
 #if CQVI_DETAILS
-	cout << "Destroying VI CQ." << endl;
+	std::cout << "Destroying VI CQ." << std::endl;
 #endif
 
 	// Destroy the completion queue.
@@ -121,7 +121,7 @@
 	result = vipl.VipDestroyCQ(completion_queue);
 
 	if (result != VIP_SUCCESS) {
-		cout << "*** Unable to VI completion queue: " << vipl.Error(result) << endl;
+		std::cout << "*** Unable to VI completion queue: " << vipl.Error(result) << std::endl;
 		return FALSE;
 	}
 
@@ -141,7 +141,7 @@
 	VIP_RETURN result;
 
 #if CQVI_DETAILS
-	cout << "Checking VI completion queue." << endl;
+	std::cout << "Checking VI completion queue." << std::endl;
 #endif
 
 	// Verify that completion queue exists.  If not, it needs to be created
@@ -159,19 +159,19 @@
 		// An I/O has completed, process it.
 	case VIP_SUCCESS:
 #if CQVI_DETAILS
-		cout << "   I/O has been posted to VI completion queue." << endl;
+		std::cout << "   I/O has been posted to VI completion queue." << std::endl;
 #endif
 
 		if (receive_done == VIP_TRUE) {
 			// Getting the completed receive.
 			if (vipl.VipRecvDone(vi, &descriptor) != VIP_SUCCESS) {
-				cout << "*** Unable to successfully complete receive." << endl;
+				std::cout << "*** Unable to successfully complete receive." << std::endl;
 				return ReturnError;
 			}
 		} else {
 			// Getting the completed send.
 			if (vipl.VipSendDone(vi, &descriptor) != VIP_SUCCESS) {
-				cout << "*** Unable to successfully complete send." << endl;
+				std::cout << "*** Unable to successfully complete send." << std::endl;
 				return ReturnError;
 			}
 		}
@@ -181,13 +181,13 @@
 	case VIP_NOT_DONE:
 	case VIP_TIMEOUT:
 #if CQVI_DETAILS
-		cout << "   no completions posted within the timeout period." << endl;
+		std::cout << "   no completions posted within the timeout period." << std::endl;
 #endif
 		return ReturnTimeout;
 
 	default:
 #if CQVI_DETAILS
-		cout << "   error checking completion queue: " << vipl.Error(result) << endl;
+		std::cout << "   error checking completion queue: " << vipl.Error(result) << std::endl;
 #endif
 		return ReturnError;
 	}
@@ -200,8 +200,8 @@
 	if (*data != CONTROL_MESSAGE) {
 		// It was for an I/O request.
 #if CQVI_DETAILS
-		cout << "   completed " << (receive_done ? "receive" : "send")
-		    << " for transaction " << *data << endl;
+		std::cout << "   completed " << (receive_done ? "receive" : "send")
+		    << " for transaction " << *data << std::endl;
 #endif
 
 		// Perform additional processing on completed receives.
@@ -217,7 +217,7 @@
 			// complete until after it's been requested.
 			if (vi_target->requested_receives-- <= 0) {
 #if CQVI_DETAILS
-				cout << "   receive has not been requested yet." << endl;
+				std::cout << "   receive has not been requested yet." << std::endl;
 #endif
 				return ReturnRetry;
 			}
@@ -231,7 +231,7 @@
 	// information.
 	//
 #if CQVI_DETAILS
-	cout << "   completion is for maintaining flow control." << endl;
+	std::cout << "   completion is for maintaining flow control." << std::endl;
 #endif
 
 	// If we received a control message, update that more sends are available.
No differences encountered
--- iometer-1.1.0-rc1/src/IOManager.h.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOManager.h	Mon Aug 20 18:19:00 2012
@@ -132,7 +132,7 @@
 	void *data;		// Buffer for I/O requests.
 	int data_size;		// Size of currently allocated data buffer.
 
-	map<DWORDLONG,unsigned char*> randomDataBuffers; // Keeps track of random data buffers. One per unique seed.
+	std::map<DWORDLONG,unsigned char*> randomDataBuffers; // Keeps track of random data buffers. One per unique seed.
 	BOOL IsWrite;
 
 	void GenerateRandomData(); // Generates random data buffers. One per unique seed.
--- iometer-1.1.0-rc1/src/IOPerformance.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOPerformance.cpp	Mon Aug 20 18:18:45 2012
@@ -112,7 +112,7 @@
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 	// Allocating buffer to receive performance data.
 	if (!(perf_data = (LPBYTE) malloc(MAX_PERF_SIZE))) {
-		cout << "*** Unable to allocate space for performance data." << endl << flush;
+		std::cout << "*** Unable to allocate space for performance data." << std::endl << std::flush;
 		exit(1);
 	}
 	perf_size = MAX_PERF_SIZE;
@@ -132,10 +132,10 @@
 	network_interfaces = 0;
 
 	if (!timer_resolution || !processor_count) {
-		cout << "*** Unable to initialize needed performance data." << endl
-		    << "This error may indicate that you are trying to run on an unsupported" << endl
-		    << "processor or OS.  See the Iometer User's Guide for information on" << endl
-		    << "supported platforms." << endl;
+		std::cout << "*** Unable to initialize needed performance data." << std::endl
+		    << "This error may indicate that you are trying to run on an unsupported" << std::endl
+		    << "processor or OS.  See the Iometer User's Guide for information on" << std::endl
+		    << "supported platforms." << std::endl;
 		exit(1);
 	}
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
@@ -175,7 +175,7 @@
 	// Open and obtain a handle to the kstat.
 	kc = kstat_open();
 	if (kc == NULL) {
-		cout << "kstat open failed with error " << errno << endl;
+		std::cout << "kstat open failed with error " << errno << std::endl;
 		// exit(1);
 	}
 	// Note that cpu count is already in place.
@@ -200,7 +200,7 @@
 	myifconf.ifc_buf = buf;
 
 	if (ioctl(sockfd, SIOCGIFCONF, (char *)&myifconf) < 0) {
-		cout << "ioctl (SIOCGIFCONF) failed with error " << errno << endl;
+		std::cout << "ioctl (SIOCGIFCONF) failed with error " << errno << std::endl;
 		exit(1);
 	}
 	// else ioctl succeeded and we have all the data !
@@ -212,7 +212,7 @@
 			continue;
 		// ioctl (SIOCGIFFLAGS) on the socket.
 		if (ioctl(sockfd, SIOCGIFFLAGS, (char *)ifreqp) < 0) {
-			cout << "ioctl (SIOCGIFFLAGS) failed with error " << errno << endl;
+			std::cout << "ioctl (SIOCGIFFLAGS) failed with error " << errno << std::endl;
 			exit(1);
 		}
 		if (!(ifreqp->ifr_flags & IFF_LOOPBACK))
@@ -233,12 +233,12 @@
 		// comes anywhere near these numbers.
 		ctlbuf = (char *)malloc(64);
 		if (ctlbuf == NULL) {
-			cout << "unable to allocate memory " << endl;
+			std::cout << "unable to allocate memory " << std::endl;
 			exit(1);
 		}
 		databuf = (char *)malloc(1024);
 		if (databuf == NULL) {
-			cout << "unable to allocate memory " << endl;
+			std::cout << "unable to allocate memory " << std::endl;
 			exit(1);
 		}
 		streamfd = 0;
@@ -283,10 +283,10 @@
 	SetLastError(0);
 	GetSystemInfo(&system_info);
 	if (GetLastError()) {
-		cout << "*** Unable to determine number of processors in system.";
+		std::cout << "*** Unable to determine number of processors in system.";
 		return 0;
 	}
-	cout << "Number of processors: " << system_info.dwNumberOfProcessors << endl;
+	std::cout << "Number of processors: " << system_info.dwNumberOfProcessors << std::endl;
 	return (int)system_info.dwNumberOfProcessors;
 #else
 #warning ===> WARNING: You have to do some coding here to get the port done!
@@ -345,14 +345,14 @@
 	}
 
 	if (!rdtsc_supported) {
-		cout << "*** Processor does not support RDTSC/ITC instruction!" << endl <<
-		    "    Dynamo requires this for high-resolution timing." << endl;
+		std::cout << "*** Processor does not support RDTSC/ITC instruction!" << std::endl <<
+		    "    Dynamo requires this for high-resolution timing." << std::endl;
 		return (double)0.0;
 	}
 	// Retrieving the estimated speed from the NT system registry.
 	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0\0",
 			 0, KEY_READ, &processor_speed_key) != ERROR_SUCCESS) {
-		cout << "*** Could not locate processor information in registry." << endl;
+		std::cout << "*** Could not locate processor information in registry." << std::endl;
 		return (double)0.0;
 	}
 	if (RegQueryValueEx(processor_speed_key, "~MHz\0", NULL, &type, (LPBYTE) & speed, &size_of_speed)
@@ -360,7 +360,7 @@
 		/* if getting MHz fails try to get GHz */
 		if (RegQueryValueEx(processor_speed_key, "~GHz\0", NULL, &type, (LPBYTE) & speed, &size_of_speed)
 		    != ERROR_SUCCESS) {
-			cout << "*** Could not retrieve estimated processor speed from registry." << endl;
+			std::cout << "*** Could not retrieve estimated processor speed from registry." << std::endl;
 			return (double)0.0;
 		} else {
 			speed_magnitude = 1;	/* set to GHz */
@@ -387,7 +387,7 @@
 		// This call should succeed. Else it means that the system has no processors !!!
 		// ("its haunted" !!!) or that this call is unsupported.
 		if (processor_info((processorid_t) j, &infop) < 0) {
-			cout << "*** Could not determine processor speed." << endl << flush;
+			std::cout << "*** Could not determine processor speed." << std::endl << std::flush;
 			return (double)0.0;
 		}
 		// found a processor and also the obtained the infop structure. So break.
@@ -394,7 +394,7 @@
 		break;
 	}
 	if (j == MAX_CPUS) {
-		cout << "*** Could not determine processor speed." << endl << flush;
+		std::cout << "*** Could not determine processor speed." << std::endl << std::flush;
 		return (double)0.0;
 	}
 	// If there are more than one processors, well, we get the speed of the first one.
@@ -410,9 +410,9 @@
 		if (((int)speed > speed_values[i] - 5) && ((int)speed < speed_values[i] + 5)) {
 			speed = speed_values[i];
 			if (speed < 1000) {
-				cout << "Processor speed: " << speed << " MHz." << endl;
+				std::cout << "Processor speed: " << speed << " MHz." << std::endl;
 			} else {
-				cout << "Processor speed: " << speed / 1000.0 << " GHz." << endl;
+				std::cout << "Processor speed: " << speed / 1000.0 << " GHz." << std::endl;
 			}
 			return (double)(speed * 1000000);
 		}
@@ -420,9 +420,9 @@
 	// Round the registry value to the nearest 10
 	speed = ((speed + 5) / 10) * 10;
 	if (speed < 1000) {
-		cout << "Processor speed: " << speed << " MHz." << endl;
+		std::cout << "Processor speed: " << speed << " MHz." << std::endl;
 	} else {
-		cout << "Processor speed: " << speed / 1000.0 << " GHz." << endl;
+		std::cout << "Processor speed: " << speed / 1000.0 << " GHz." << std::endl;
 	}
 	return (double)(speed * 1000000);
 }
@@ -480,7 +480,7 @@
 
 	// Get the performance data stored by the system.
 #ifdef _DEBUG
-	cout << "   Getting system performance data." << endl << flush;
+	std::cout << "   Getting system performance data." << std::endl << std::flush;
 #endif
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
@@ -494,14 +494,14 @@
 		if (query_result == ERROR_MORE_DATA) {
 			// More data than we had room for!  Try a bigger buffer.
 #ifdef _DEBUG
-			cout << "   RegQueryValueEx() returned ERROR_MORE_DATA!  Number of bytes used: "
-			    << perf_object_size << endl << flush
+			std::cout << "   RegQueryValueEx() returned ERROR_MORE_DATA!  Number of bytes used: "
+			    << perf_object_size << std::endl << std::flush
 			    << "   Bumping performance data buffer up from " << perf_size
-			    << " to " << perf_size + MAX_PERF_SIZE << " bytes." << endl << flush;
+			    << " to " << perf_size + MAX_PERF_SIZE << " bytes." << std::endl << std::flush;
 #endif
 			perf_size += MAX_PERF_SIZE;
 			if (!(perf_data = (LPBYTE) realloc(perf_data, perf_size))) {
-				cout << "Error allocating more space for performance data." << endl << flush;
+				std::cout << "Error allocating more space for performance data." << std::endl << std::flush;
 				exit(1);
 			}
 			perf_object_size = perf_size;
@@ -512,24 +512,24 @@
 			if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM, NULL,	// get message from system
 					  query_result, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),	// default language
 					  (LPSTR) & message, 0, NULL)) {
-				cout << "Error " << query_result << " getting performance data: " << message << flush;
+				std::cout << "Error " << query_result << " getting performance data: " << message << std::flush;
 				LocalFree(message);
 			} else {
 				// FormatMessage failed, just print error number
-				cout << "Error " << query_result << " getting performance data." << endl << flush;
+				std::cout << "Error " << query_result << " getting performance data." << std::endl << std::flush;
 			}
 
 			// special case for known Win95 error
 			if (query_result == ERROR_KEY_DELETED) {
-				cout << "This error may indicate that Dynamo is being run under Windows 95." << endl
-				    << "Windows 95 is not supported; Dynamo requires Windows NT 4.0 or greater." << endl
-				    << flush;
+				std::cout << "This error may indicate that Dynamo is being run under Windows 95." << std::endl
+				    << "Windows 95 is not supported; Dynamo requires Windows NT 4.0 or greater." << std::endl
+				    << std::flush;
 			}
 			return;
 		}
 	}			// end while (trying to query registry values)
 #if PERFORMANCE_DETAILS || _DETAILS
-	cout << "   Number of bytes used for performance data: " << perf_object_size << endl << flush;
+	std::cout << "   Number of bytes used for performance data: " << perf_object_size << std::endl << std::flush;
 #endif
 
 	// Record time that snapshot was taken.
@@ -540,10 +540,10 @@
 		// Yes, get the update frequency.
 		perf_update_freq = (_int64) ((PERF_DATA_BLOCK *) perf_data)->PerfFreq.QuadPart;
 #if PERFORMANCE_DETAILS || _DETAILS
-		cout << "   Performance update frequency = " 
+		std::cout << "   Performance update frequency = " 
 			<< perf_update_freq 
-			<< endl
-			<< flush;
+			<< std::endl
+			<< std::flush;
 #endif
 
 		// Calculate the length of time that measurements were taken.
@@ -554,7 +554,7 @@
 			perf_time = (double)0.0;	// Error gathering performance time, mark as invalid.
 		}
 #ifdef _DEBUG
-		cout << "   Performance time = " << perf_time << endl << flush;
+		std::cout << "   Performance time = " << perf_time << std::endl << std::flush;
 #endif
 	}
 	Extract_Counters(perf_data_type, snapshot);
@@ -598,7 +598,7 @@
 		// Loop through the counters and calculate performance.
 		for (stat = 0; stat < CPU_RESULTS; stat++) {
 #if PERFORMANCE_DETAILS
-			cout << "Calculating stat " << stat << " for CPU " << cpu << endl;
+			std::cout << "Calculating stat " << stat << " for CPU " << cpu << std::endl;
 #endif
 
 #if defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
@@ -605,8 +605,8 @@
 			// If we've never set the counter offsets, then we've never successfully retrieved
 			// the performance data.  Set all of the values to 0.
 			if (cpu_perf_counter_info[stat].offset == IOERROR) {
-				cout << "*** Offset to CPU performance counter not defined for stat "
-				    << stat << "." << endl;
+				std::cout << "*** Offset to CPU performance counter not defined for stat "
+				    << stat << "." << std::endl;
 				cpu_results->CPU_utilization[cpu][stat] = (double)0.0;
 			} else {
 				cpu_results->CPU_utilization[cpu][stat] =
@@ -639,7 +639,7 @@
 					// So, it is better to comment it out rather than have the message
 					// pop up on the screen at regular intervals.
 					//
-					// cout << "***** Error : CPU utilization outside valid range 0% - 100% *****" << endl;
+					// std::cout << "***** Error : CPU utilization outside valid range 0% - 100% *****" << std::endl;
 				}
 				if (result > 1.0) {
 					result = 1.0;
@@ -654,8 +654,8 @@
 #endif
 
 #if PERFORMANCE_DETAILS || _DETAILS
-			cout << "CPU " << cpu << " recorded stat " << stat << " = "
-			    << cpu_results->CPU_utilization[cpu][stat] << endl;
+			std::cout << "CPU " << cpu << " recorded stat " << stat << " = "
+			    << cpu_results->CPU_utilization[cpu][stat] << std::endl;
 #endif
 		}
 	}
@@ -693,7 +693,7 @@
 #endif
 
 #if PERFORMANCE_DETAILS || _DETAILS
-		cout << "TCP recorded stat " << stat << " = " << net_results->tcp_stats[stat] << endl;
+		std::cout << "TCP recorded stat " << stat << " = " << net_results->tcp_stats[stat] << std::endl;
 #endif
 	}
 }
@@ -744,8 +744,8 @@
 #endif
 
 #if PERFORMANCE_DETAILS || _DETAILS
-			cout << "   Network interface " << net << " recorded stat " << stat << " = "
-			    << net_results->ni_stats[net][stat] << endl;
+			std::cout << "   Network interface " << net << " recorded stat " << stat << " = "
+			    << net_results->ni_stats[net][stat] << std::endl;
 #endif
 		}
 	}
@@ -766,7 +766,7 @@
 		if (strcmp(ksp->ks_module, "cpu_stat") == 0) {
 			// found a cpu_stat.
 			if (-1 == kstat_read(kc, ksp, NULL)) {
-				cout << "kstat_read() failed with error " << errno << endl;
+				std::cout << "kstat_read() failed with error " << errno << std::endl;
 				exit(1);
 			}
 			// else kstat_read thru..
@@ -801,12 +801,12 @@
 	}
 	// only root can open "/dev/ip" and push "tcp" module onto it.
 	if ((streamfd = open("/dev/ip", O_RDWR, 0600)) < 0) {
-		cout << "unable to open /dev/ip" << endl;
+		std::cout << "unable to open /dev/ip" << std::endl;
 		streamfd = -1;
 		return;
 	}
 	if (ioctl(streamfd, I_PUSH, "tcp") < 0) {
-		cout << "unable to push tcp module onto the stream" << endl;
+		std::cout << "unable to push tcp module onto the stream" << std::endl;
 		close(streamfd);
 		streamfd = -1;
 	} else {
@@ -845,7 +845,7 @@
 
 	// Now putmsg() the ctl info onto the stream.
 	if (putmsg(streamfd, &strbuf_ctl, NULL, 0) == -1) {
-		cout << "putmsg() call failed with error " << errno << endl;
+		std::cout << "putmsg() call failed with error " << errno << std::endl;
 		raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = 0;
 		close(streamfd);
 		return;
@@ -856,7 +856,7 @@
 
 	// First get the reponse to the control message.
 	if ((retval = getmsg(streamfd, &strbuf_ctl, NULL, &flags)) < 0) {
-		cout << "getmsg() call failed with error " << errno << endl;
+		std::cout << "getmsg() call failed with error " << errno << std::endl;
 		raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = 0;
 		close(streamfd);
 		return;
@@ -876,7 +876,7 @@
 		strbuf_data.len = 0;
 		strbuf_data.maxlen = opthdr->len;
 		if ((retval == getmsg(streamfd, NULL, &strbuf_data, &flags)) != 0) {
-			cout << "getmsg() call (data) failed with error " << errno << endl;
+			std::cout << "getmsg() call (data) failed with error " << errno << std::endl;
 			raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = 0;
 			close(streamfd);
 			return;
@@ -884,7 +884,7 @@
 		// retval == 0  is the only case where we have good data
 		raw_tcp_data[TCP_SEGMENTS_RESENT][snapshot] = ((struct mib2_tcp *)(strbuf_data.buf))->tcpRetransSegs;
 #if _DETAILS
-		cout << "tcp segments retrans : " << ((struct mib2_tcp *)(strbuf_data.buf))->tcpRetransSegs << endl;
+		std::cout << "tcp segments retrans : " << ((struct mib2_tcp *)(strbuf_data.buf))->tcpRetransSegs << std::endl;
 #endif
 	}
 	close(streamfd);
@@ -905,7 +905,7 @@
 		if (strcmp(ksp->ks_name, nic_names[current_nic]) == 0) {
 			// found the interface we are looking for.
 			if (0 > kstat_read(kc, ksp, NULL)) {
-				cout << "kstat_read() failed with error " << errno << endl;
+				std::cout << "kstat_read() failed with error " << errno << std::endl;
 				exit(1);
 			}
 			// store data into raw_ni_data. First initialize for this snapshot to 
@@ -950,24 +950,24 @@
 	switch (perf_data_type) {
 	case PERF_PROCESSOR:
 #ifdef _DEBUG
-		cout << "Extracting processor data." << endl << flush;
+		std::cout << "Extracting processor data." << std::endl << std::flush;
 #endif
 		Extract_CPU_Counters(snapshot);
 		break;
 	case PERF_NETWORK_TCP:
 #ifdef _DEBUG
-		cout << "   Extracting network TCP data." << endl << flush;
+		std::cout << "   Extracting network TCP data." << std::endl << std::flush;
 #endif
 		Extract_TCP_Counters(snapshot);
 		break;
 	case PERF_NETWORK_INTERFACE:
 #ifdef _DEBUG
-		cout << "   Extracting network interface data." << endl << flush;
+		std::cout << "   Extracting network interface data." << std::endl << std::flush;
 #endif
 		Extract_NI_Counters(snapshot);
 		break;
 	default:
-		cout << "*** Unknown performance data requested: " << perf_data_type << endl << flush;
+		std::cout << "*** Unknown performance data requested: " << perf_data_type << std::endl << std::flush;
 		return;
 	}
 }
@@ -998,7 +998,7 @@
 
 		if (strncmp(cpu_name, cpu_reg_name, 2)) {
 #ifdef _DEBUG
-			cout << "Performing exhaustive search for processor instance " << cpu << endl;
+			std::cout << "Performing exhaustive search for processor instance " << cpu << std::endl;
 #endif
 
 			// Check all processor instances and 
@@ -1007,7 +1007,7 @@
 				if (!Locate_Perf_Instance(i))
 					return;
 #if PERFORMANCE_DETAILS || _DETAILS
-				cout << "Looking at processor name: " << (char *)cpu_reg_name << endl;
+				std::cout << "Looking at processor name: " << (char *)cpu_reg_name << std::endl;
 #endif
 				// Match the name of the current instance with 
 				//      the name of the desired cpu.
@@ -1015,7 +1015,7 @@
 					break;	// Found the correct instance.
 			}
 			if (i == perf_object->NumInstances) {
-				cout << "*** Unable to locate performance instance of processor " << cpu_name << endl;
+				std::cout << "*** Unable to locate performance instance of processor " << cpu_name << std::endl;
 				return;
 			}
 		}
@@ -1022,7 +1022,7 @@
 		// Saving CPU specific counters.
 		for (stat = 0; stat < CPU_RESULTS; stat++) {
 #if PERFORMANCE_DETAILS || _DETAILS
-			cout << "Extracting CPU stat " << stat << " for CPU " << cpu_name << endl;
+			std::cout << "Extracting CPU stat " << stat << " for CPU " << cpu_name << std::endl;
 #endif
 			raw_cpu_data[cpu][stat][snapshot] = Extract_Counter(&(cpu_perf_counter_info[stat]));
 		}
@@ -1041,7 +1041,7 @@
 		return;
 	for (stat = 0; stat < TCP_RESULTS; stat++) {
 #if PERFORMANCE_DETAILS || _DETAILS
-		cout << "Extracting TCP stat " << stat << endl;
+		std::cout << "Extracting TCP stat " << stat << std::endl;
 #endif
 		raw_tcp_data[stat][snapshot] = Extract_Counter(&(tcp_perf_counter_info[stat]));
 	}
@@ -1064,7 +1064,7 @@
 		// Saving network NI specific counters.
 		for (stat = 0; stat < NI_RESULTS; stat++) {
 #if PERFORMANCE_DETAILS || _DETAILS
-			cout << "Extracting NI stat " << stat << " for NI " << network_interfaces << endl;
+			std::cout << "Extracting NI stat " << stat << " for NI " << network_interfaces << std::endl;
 #endif
 			raw_ni_data[network_interfaces][stat][snapshot] =
 			    Extract_Counter(&(ni_perf_counter_info[stat]));
@@ -1081,7 +1081,7 @@
 {
 	// Verify that we know where to locate the counter.
 	if (counter_info->offset == IOERROR) {
-		cout << "*** Unable to extract performance counter, offset not set." << endl << flush;
+		std::cout << "*** Unable to extract performance counter, offset not set." << std::endl << std::flush;
 		return (_int64) 0;
 	}
 
@@ -1091,7 +1091,7 @@
 	case PERF_SIZE_DWORD:
 		return (_int64) * ((DWORD *) ((LPBYTE) perf_counters + counter_info->offset));
 	default:		// other counter types exist, but are not currently used - signal error
-		cout << "*** Unknown size of performance data." << endl << flush;
+		std::cout << "*** Unknown size of performance data." << std::endl << std::flush;
 	}
 	return (_int64) 0;
 }
@@ -1123,8 +1123,8 @@
 	if (i >= (int)pperf_data->NumObjectTypes) {
 		perf_object = NULL;
 #if PERFORMANCE_DETAILS || defined(_DEBUG)
-		cout << "No current performance object to retrieve counters from." << endl
-		    << "   Searching for " << perf_object_index << endl << flush;
+		std::cout << "No current performance object to retrieve counters from." << std::endl
+		    << "   Searching for " << perf_object_index << std::endl << std::flush;
 #endif
 		return FALSE;
 	}
@@ -1142,7 +1142,7 @@
 	if (perf_object->NumInstances == PERF_NO_INSTANCES) {
 		// Verify that we were not expecting multiple instances to be supported.
 		if (instance != PERF_NO_INSTANCES) {
-			cout << "*** One performance instance was found, but more were expected." << endl << flush;
+			std::cout << "*** One performance instance was found, but more were expected." << std::endl << std::flush;
 			return FALSE;
 		}
 		// Only one instance supported, just set a pointer to the performance counters.
@@ -1151,7 +1151,7 @@
 	} else {
 		// Verify that we were expecting to find multiple instances.
 		if (instance == PERF_NO_INSTANCES) {
-			cout << "*** Multiple performance instances were found, but not expected." << endl << flush;
+			std::cout << "*** Multiple performance instances were found, but not expected." << std::endl << std::flush;
 			return FALSE;
 		}
 		// Multiple instances supported.  Locate the counters to the correct one.
@@ -1198,7 +1198,7 @@
 		counter_info = (Perf_Counter_Info *) (&(ni_perf_counter_info[0]));
 		break;
 	default:
-		cout << "*** Unknown performance data requested: " << perf_data_type << endl << flush;
+		std::cout << "*** Unknown performance data requested: " << perf_data_type << std::endl << std::flush;
 		return FALSE;
 	}
 
@@ -1234,7 +1234,7 @@
 // *** Removed:  Need to add back in if using getTickCount.
 //
 //#ifndef WIN64_COUNTER_WORKAROUND
-//              cout << "*** Performance time not positive." << endl;
+//              std::cout << "*** Performance time not positive." << std::endl;
 //#endif
 //
 // *** End Removed.
@@ -1247,24 +1247,24 @@
 		// Dealing with a number (e.g. error count)
 	case PERF_TYPE_NUMBER:
 #if PERFORMANCE_DETAILS
-		cout << "Performing calculation on a performance number." << endl;
+		std::cout << "Performing calculation on a performance number." << std::endl;
 #endif
 		switch (counter_type & PERF_SUBTYPE_MASK) {
 		case PERF_NUMBER_DECIMAL:
 #if PERFORMANCE_DETAILS
-			cout << "Performance number decimal." << endl;
+			std::cout << "Performance number decimal." << std::endl;
 #endif
 			perf_stat = (double)(end_value - start_value);
 			break;
 		case PERF_NUMBER_DEC_1000:	// divide result by 1000 before displaying
 #if PERFORMANCE_DETAILS
-			cout << "Performance number decimal x 1000." << endl;
+			std::cout << "Performance number decimal x 1000." << std::endl;
 #endif
 			perf_stat = (double)(end_value - start_value) / (double)1000.0;
 			break;
 			// other subtypes exist, but are not handled
 		default:
-			cout << "*** Performance counter number subtype not handled" << endl;
+			std::cout << "*** Performance counter number subtype not handled" << std::endl;
 			return (double)0.0;
 		}
 		break;
@@ -1272,17 +1272,17 @@
 		// Dealing with an actual counter value.
 	case PERF_TYPE_COUNTER:
 #if PERFORMANCE_DETAILS
-		cout << "Performing calculation on a performance counter." << endl;
+		std::cout << "Performing calculation on a performance counter." << std::endl;
 #endif
 
 		// Computing the difference between the two counters.
 		if (counter_type & PERF_DELTA_COUNTER) {
 #if PERFORMANCE_DETAILS
-			cout << "Performance delta counter." << endl;
+			std::cout << "Performance delta counter." << std::endl;
 #endif
 			count_difference = (double)(end_value - start_value);
 		} else {
-			cout << "*** Unhandled performance counter delta type." << endl;
+			std::cout << "*** Unhandled performance counter delta type." << std::endl;
 			return (double)0.0;
 		}
 
@@ -1292,7 +1292,7 @@
 			// Divide the counter by the time difference
 		case PERF_COUNTER_RATE:
 #if PERFORMANCE_DETAILS
-			cout << "Performance counter is a rate." << endl;
+			std::cout << "Performance counter is a rate." << std::endl;
 #endif
 
 			// Adjust the time based on the counter's update frequency.
@@ -1300,7 +1300,7 @@
 				// Timer is based on the system timer, just use it.
 			case PERF_TIMER_TICK:
 #if PERFORMANCE_DETAILS
-				cout << "Using system timer for update frequency." << endl;
+				std::cout << "Using system timer for update frequency." << std::endl;
 #endif
 				perf_stat = count_difference / perf_time;
 				break;
@@ -1308,7 +1308,7 @@
 				// These timers are based on a 100-ns timer, so multiply timer by 10,000,000 to get seconds.
 			case PERF_TIMER_100NS:
 #if PERFORMANCE_DETAILS
-				cout << "Using 100-ns timer for update frequency." << endl;
+				std::cout << "Using 100-ns timer for update frequency." << std::endl;
 #endif
 				perf_stat = count_difference / (perf_time * (double)10000000.0);
 				break;
@@ -1315,13 +1315,13 @@
 
 				// other timer rates exist, but are not handled.
 			default:
-				cout << "*** Performance update frequency type not handled." << endl;
+				std::cout << "*** Performance update frequency type not handled." << std::endl;
 				return (double)0.0;
 			}
 
 			break;
 		default:
-			cout << "*** Unhandled performance counter, counter subtype." << endl;
+			std::cout << "*** Unhandled performance counter, counter subtype." << std::endl;
 			return (double)0.0;
 		}
 
@@ -1329,7 +1329,7 @@
 
 		// other types exist, but are not handled
 	default:
-		cout << "*** Unhandled performance counter type." << endl;
+		std::cout << "*** Unhandled performance counter type." << std::endl;
 		return (double)0.0;
 	}
 
@@ -1336,7 +1336,7 @@
 	// Handle any inverted performance counters.
 	if (counter_type & PERF_INVERSE_COUNTER) {
 #if PERFORMANCE_DETAILS
-		cout << "Inverting performance counter (1 - value)." << endl;
+		std::cout << "Inverting performance counter (1 - value)." << std::endl;
 #endif
 		perf_stat = (double)1.0 - perf_stat;
 	}
@@ -1348,18 +1348,18 @@
 
 	case PERF_DISPLAY_PERCENT:	// scale by 100 to reflect a percentage
 #if PERFORMANCE_DETAILS
-		cout << "Performance counter is a percent." << endl;
+		std::cout << "Performance counter is a percent." << std::endl;
 #endif
 		// Verify valid values.  
 		// Do not print an error message unless it's more than trivially invalid.
 		if (perf_stat < (double)0.0) {
 			if (perf_stat < (double)-0.001) {
-				cout << "*** Performance counter percentage is less than zero: " << perf_stat << endl;
+				std::cout << "*** Performance counter percentage is less than zero: " << perf_stat << std::endl;
 			}
 			return (double)0.0;
 		} else if (perf_stat > (double)1.0) {
 			if (perf_stat > (double)1.001) {
-				cout << "*** Performance counter percentage is greater than 1: " << perf_stat << endl;
+				std::cout << "*** Performance counter percentage is greater than 1: " << perf_stat << std::endl;
 			}
 			return (double)100.0;
 		}
@@ -1367,7 +1367,7 @@
 		return (perf_stat * (double)100.0);
 
 	default:
-		cout << "*** Unhandled performance display suffix." << endl;
+		std::cout << "*** Unhandled performance display suffix." << std::endl;
 		return (double)0.0;
 	}
 }
--- iometer-1.1.0-rc1/src/ICF_ifstream.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/ICF_ifstream.cpp	Mon Aug 20 18:18:45 2012
@@ -5,7 +5,7 @@
 /* ## ------------------------------------------------------------------- ## */
 /* ##                                                                     ## */
 /* ##  Job .......: Implementation of the ICF_ifstream class, which       ## */
-/* ##               extends the standard "ifstream" class with            ## */
+/* ##               extends the standard "std::ifstream" class with            ## */
 /* ##               additional functionality for reading and writing      ## */
 /* ##               Iometer's .ICF (Iometer Configuration File) files.    ## */
 /* ##                                                                     ## */
--- iometer-1.1.0-rc1/src/IOPort.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOPort.cpp	Mon Aug 20 18:18:46 2012
@@ -76,7 +76,7 @@
 /* ##               2003-02-15 (daniel.scheibli@edelbyte.org)             ## */
 /* ##               - Added new header holding the changelog.             ## */
 /* ##               - Different changes to support compilation with       ## */
-/* ##                 gcc 3.2 (known as cout << hex error).               ## */
+/* ##                 gcc 3.2 (known as std::cout << hex error).               ## */
 /* ##                                                                     ## */
 /* ######################################################################### */
 
@@ -111,7 +111,7 @@
 	synchronous = synch;
 	name[0] = '\0';
 	type = PORT_TYPE_INVALID;
-	errmsg = new ostringstream;
+	errmsg = new std::ostringstream;
 	accept_overlapped.hEvent = NULL;
 	receive_overlapped.hEvent = NULL;
 	send_overlapped.hEvent = NULL;
@@ -141,7 +141,7 @@
 
 	if (olap->hEvent) {
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_NETWARE) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
-		cout << "Async Port objects not supported on UNIX or NetWare" << endl;
+		std::cout << "Async Port objects not supported on UNIX or NetWare" << std::endl;
 		return FALSE;
 #elif defined(IOMTR_OS_WIN32) || defined(IOMTR_OS_WIN64)
 		DWORD d = WaitForSingleObject(olap->hEvent, 0);
@@ -212,8 +212,8 @@
 void Port::OutputErrMsg()
 {
 	if (!errmsg) {
-		errmsg = new ostringstream;
-		*errmsg << "Port::OutputErrMsg() called with invalid errmsg value!" << ends;
+		errmsg = new std::ostringstream;
+		*errmsg << "Port::OutputErrMsg() called with invalid errmsg value!" << std::ends;
 	}
 #if defined(_GALILEO_)
 	// Iometer
@@ -220,7 +220,7 @@
 	ErrorMessage(errmsg->str().c_str());
 #else
 	// Dynamo
-	cout << errmsg->str() << endl;
+	std::cout << errmsg->str() << std::endl;
 #endif
 
 	// str() returns pointer to buffer and freezes it, we must call freeze(FALSE) to 
@@ -227,11 +227,11 @@
 	// unfreeze the buffer before we can delete the object
 	// ---
 	// REMARK: freeze() no longer needed because new are now
-	// using ostringstream instead of ostrstream.
+	// using std::ostringstream instead of ostrstream.
 	//
 	// errmsg->rdbuf()->freeze( FALSE );
 
 	delete errmsg;
 
-	errmsg = new ostringstream;
+	errmsg = new std::ostringstream;
 }
--- iometer-1.1.0-rc1/src/IOCompletionQ.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOCompletionQ.cpp	Mon Aug 20 18:18:46 2012
@@ -103,7 +103,7 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	if (this_cqid->element_list == NULL) {
-		cout << "memory allocation failed" << endl;
+		std::cout << "memory allocation failed" << std::endl;
 		return (FALSE);
 	}
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
@@ -114,7 +114,7 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	if (this_cqid->aiocb_list == NULL) {
-		cout << "memory allocation failed" << endl;
+		std::cout << "memory allocation failed" << std::endl;
 #if defined(IOMTR_OS_LINUX) || defined(IOMTR_OS_OSX) || defined(IOMTR_OS_SOLARIS)
 		free(this_cqid->element_list);
 #elif defined(IOMTR_OS_NETWARE)
@@ -132,7 +132,7 @@
 	this_cqid->position = 0;
 
 #ifdef _DEBUG
-	cout << "allocated a completion queue of size " << size << " for handle : " << this_cqid << endl;
+	std::cout << "allocated a completion queue of size " << size << " for handle : " << this_cqid << std::endl;
 #endif
 	return (TRUE);
 }
@@ -163,7 +163,7 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 		if (cqid == NULL) {
-			cout << "memory allocation failed. Exiting...." << endl;
+			std::cout << "memory allocation failed. Exiting...." << std::endl;
 			exit(1);
 		}
 		cqid->element_list = NULL;
@@ -208,7 +208,7 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	if (eventqid == NULL) {
-		cout << "memory allocation failed. Exiting...." << endl;
+		std::cout << "memory allocation failed. Exiting...." << std::endl;
 		return (NULL);
 	}
 	eventqid->element_list = NULL;
@@ -433,7 +433,7 @@
 			return (FALSE);
 		}
 #ifdef _DEBUG
-		cout << "aio_suspend returned error " << errno << endl;
+		std::cout << "aio_suspend returned error " << errno << std::endl;
 #endif
 		SetLastError(errno);
 		return (FALSE);
@@ -524,7 +524,7 @@
 		this_cq = filep->iocq;
 
 	if (this_cq == NULL) {
-		cout << "event or completion queue not allocated " << endl;
+		std::cout << "event or completion queue not allocated " << std::endl;
 		return (FALSE);
 	}
 	// First locate an empty slot in the queue.
@@ -571,11 +571,11 @@
 	{
 		if (errno == EAGAIN)
 		{
-			cout << "aio_read64 failed with EAGAIN -- system limitation???" << endl;
+			std::cout << "aio_read64 failed with EAGAIN -- system limitation???" << std::endl;
 		}
 		else
 		{
-			cout << "queuing for read failed with error " << errno << endl;
+			std::cout << "queuing for read failed with error " << errno << std::endl;
 		}
 		// Note that we have not set aiocb_list[] with the correct pointers.
 		// So, this slot will get grabbed in the next loop.
@@ -639,7 +639,7 @@
 		this_cq = filep->iocq;
 
 	if (this_cq == NULL) {
-		cout << "event or completion queue not allocated " << endl;
+		std::cout << "event or completion queue not allocated " << std::endl;
 		return (FALSE);
 	}
 	// First locate an empty slot in the queue.
@@ -683,7 +683,7 @@
 #warning ===> WARNING: You have to do some coding here to get the port done!
 #endif
 	{
-		cout << "queuing for write failed with error " << errno << endl;
+		std::cout << "queuing for write failed with error " << errno << std::endl;
 		// Note that we have not set aiocb_list[] with the correct pointers.
 		// So, this slot will get grabbed in the next loop.
 		SetLastError(errno);
@@ -734,7 +734,7 @@
 	int retval, i;
 
 #ifdef _DEBUG
-	cout << "CloseHandle() freeing : handle = " << object << " objecttype = " << object_type << endl;
+	std::cout << "CloseHandle() freeing : handle = " << object << " objecttype = " << object_type << std::endl;
 #endif
 
 	switch (object_type) {
@@ -877,7 +877,7 @@
 	if (radix == 10)
 		sprintf(string, "%d", value);
 	else {
-		cerr << "_itoa() not implemented for radix != 10" << endl;
+		std::cerr << "_itoa() not implemented for radix != 10" << std::endl;
 		exit(1);
 	}
 	return (string);
--- iometer-1.1.0-rc1/src/Worker.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/Worker.cpp	Mon Aug 20 18:18:46 2012
@@ -747,7 +747,7 @@
 		(*file) << ",";	// Space for network results
 	}
 
-	(*file) << endl;
+	(*file) << std::endl;
 
 	// If requested, save target results.
 	if (result_type != RecordAll)
@@ -874,7 +874,7 @@
 		for (stat = 0; stat < NI_COMBINE_RESULTS + TCP_RESULTS; stat++)
 			(*file) << ",";	// Space for network results
 
-		(*file) << endl;
+		(*file) << std::endl;
 	}
 	if (IsType(Type(), GenericClientType))
 		delete target;
@@ -2049,18 +2049,18 @@
 	if (IsType(Type(), GenericClientType))
 		return TRUE;
 
-	outfile << "'Worker" << endl << "\t" << name << endl << "'Worker type" << endl;
+	outfile << "'Worker" << std::endl << "\t" << name << std::endl << "'Worker type" << std::endl;
 
 	// Determine the worker type.
 	if (IsType(Type(), GenericDiskType)) {
-		outfile << "\tDISK" << endl;
+		outfile << "\tDISK" << std::endl;
 	} else if (IsType(Type(), GenericNetType)) {
 		outfile << "\tNETWORK";
 
 		if (IsType(Type(), GenericTCPType))
-			outfile << ",TCP" << endl;
+			outfile << ",TCP" << std::endl;
 		else if (IsType(Type(), GenericVIType))
-			outfile << ",VI" << endl;
+			outfile << ",VI" << std::endl;
 		else {
 			ErrorMessage("Error saving worker \"" + (CString) name + "\": "
 				     "Network worker is neither TCP nor VI.");
@@ -2072,41 +2072,41 @@
 		return FALSE;
 	}
 
-	outfile << "'Default target settings for worker" << endl;
+	outfile << "'Default target settings for worker" << std::endl;
 
-	outfile << "'Number of outstanding IOs,test connection rate,transactions per connection,use fixed seed,fixed seed value" << endl;
+	outfile << "'Number of outstanding IOs,test connection rate,transactions per connection,use fixed seed,fixed seed value" << std::endl;
 	outfile << "\t" << GetQueueDepth(Type())
 		<< "," << (GetConnectionRate(Type())? "ENABLED" : "DISABLED")
 		<< "," << GetTransPerConn(Type()) 
 		<< "," << (GetUseFixedSeed(Type())? "ENABLED" : "DISABLED")
-		<< "," << GetFixedSeedValue(Type()) << endl;
+		<< "," << GetFixedSeedValue(Type()) << std::endl;
 
 	if (IsType(spec.type, GenericDiskType)) {
-		outfile << "'Disk maximum size,starting sector,Data pattern" << endl;
+		outfile << "'Disk maximum size,starting sector,Data pattern" << std::endl;
 
 		outfile << "\t" << GetDiskSize(Type())
-		    << "," << GetDiskStart(Type()) << "," << GetDataPattern(Type()) << endl;
+		    << "," << GetDiskStart(Type()) << "," << GetDataPattern(Type()) << std::endl;
 	}
 
 	if (IsType(spec.type, GenericNetType)) {
-		outfile << "'Local network interface" << endl << "\t" << GetLocalNetworkInterface() << endl;
+		outfile << "'Local network interface" << std::endl << "\t" << GetLocalNetworkInterface() << std::endl;
 	}
 
 	if (IsType(spec.type, GenericVIType)) {
-		outfile << "'VI outstanding IOs" << endl << "\t" << GetMaxSends(Type()) << endl;
+		outfile << "'VI outstanding IOs" << std::endl << "\t" << GetMaxSends(Type()) << std::endl;
 	}
 
-	outfile << "'End default target settings for worker" << endl;
+	outfile << "'End default target settings for worker" << std::endl;
 
 	if (save_aspecs) {
 		int spec_count = AccessSpecCount();
 
-		outfile << "'Assigned access specs" << endl;
+		outfile << "'Assigned access specs" << std::endl;
 
 		for (int counter = 0; counter < spec_count; counter++)
-			outfile << "\t" << access_spec_list[counter]->name << endl;
+			outfile << "\t" << access_spec_list[counter]->name << std::endl;
 
-		outfile << "'End assigned access specs" << endl;
+		outfile << "'End assigned access specs" << std::endl;
 	}
 
 	if (save_targets) {
@@ -2113,23 +2113,23 @@
 		Target_Spec tspec;
 		int target_count = TargetCount();
 
-		outfile << "'Target assignments" << endl;
+		outfile << "'Target assignments" << std::endl;
 
 		for (int counter = 0; counter < target_count; counter++) {
 			tspec = GetTarget(counter)->spec;
 
-			outfile << "'Target" << endl;
+			outfile << "'Target" << std::endl;
 
 			// Determine the worker type.
 			if (IsType(tspec.type, GenericDiskType)) {
-				outfile << "\t" << tspec.name << endl << "'Target type" << endl << "\tDISK" << endl;
+				outfile << "\t" << tspec.name << std::endl << "'Target type" << std::endl << "\tDISK" << std::endl;
 			} else if (IsType(tspec.type, GenericNetType)) {
 				if (IsType(tspec.type, GenericTCPType)) {
-					outfile << "\t" << tspec.tcp_info.remote_address << endl
-					    << "'Target type" << endl << "\tNETWORK,TCP" << endl;
+					outfile << "\t" << tspec.tcp_info.remote_address << std::endl
+					    << "'Target type" << std::endl << "\tNETWORK,TCP" << std::endl;
 				} else if (IsType(tspec.type, GenericVIType)) {
-					outfile << "\t" << tspec.vi_info.remote_nic_name << endl
-					    << "'Target type" << endl << "\tNETWORK,VI" << endl;
+					outfile << "\t" << tspec.vi_info.remote_nic_name << std::endl
+					    << "'Target type" << std::endl << "\tNETWORK,VI" << std::endl;
 				} else {
 					ErrorMessage("Error saving target \"" + (CString) tspec.name + "\": "
 						     "Network target is neither TCP nor VI.");
@@ -2142,8 +2142,8 @@
 					return FALSE;
 				}
 
-				outfile << "'Target manager ID, manager name" << endl
-				    << "\t" << net_partner->manager->id << "," << net_partner->manager->name << endl;
+				outfile << "'Target manager ID, manager name" << std::endl
+				    << "\t" << net_partner->manager->id << "," << net_partner->manager->name << std::endl;
 			} else {
 				ErrorMessage("Error saving target \"" + (CString) tspec.name + "\": "
 					     "Target is neither a DISK nor a NETWORK target.");
@@ -2150,13 +2150,13 @@
 				return FALSE;
 			}
 
-			outfile << "'End target" << endl;
+			outfile << "'End target" << std::endl;
 		}
 
-		outfile << "'End target assignments" << endl;
+		outfile << "'End target assignments" << std::endl;
 	}
 
-	outfile << "'End worker" << endl;
+	outfile << "'End worker" << std::endl;
 
 	return TRUE;
 }
--- iometer-1.1.0-rc1/src/IOAccess.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/IOAccess.cpp	Mon Aug 20 18:18:46 2012
@@ -135,7 +135,7 @@
 		start_percent = i;	// Begin again where we left off.
 		spec_no++;
 	} while (i < MAX_ACCESS_SPECS);
-	cout << "Access specifications for test defined." << endl << flush;
+	std::cout << "Access specifications for test defined." << std::endl << std::flush;
 }
 
 //
--- iometer-1.1.0-rc1/src/ManagerList.cpp.orig	Mon Nov 29 23:13:41 2010
+++ iometer-1.1.0-rc1/src/ManagerList.cpp	Mon Aug 20 18:18:46 2012
@@ -410,7 +410,7 @@
 	char acDummy[64];
 
 	// Writing result header information.
-	(*file) << "'Results" << endl
+	(*file) << "'Results" << std::endl
 	    << "'Target Type,Target Name,Access Specification Name,# Managers,"
 	    << "# Workers,# Disks,IOps,Read IOps,Write IOps,MBps (Binary),Read MBps (Binary),Write MBps (Binary),"
 		<< "MBps (Decimal),Read MBps (Decimal),Write MBps (Decimal),Transactions per Second,Connections per Second,"
@@ -428,7 +428,7 @@
 	    << "Total Raw Run Time,Starting Sector,Maximum Size,Queue Depth,"
 	    << "% CPU Utilization,% User Time,% Privileged Time,% DPC Time,"
 	    << "% Interrupt Time,Processor Speed,Interrupts per Second,"
-	    << "CPU Effectiveness,Packets/Second,Packet Errors," << "Segments Retransmitted/Second" << endl;
+	    << "CPU Effectiveness,Packets/Second,Packet Errors," << "Segments Retransmitted/Second" << std::endl;
 
 	// Writing manager list results
 
@@ -491,7 +491,7 @@
 	for (stat = 0; stat < TCP_RESULTS; stat++)
 		(*file) << "," << results[WHOLE_TEST_PERF].tcp_statistics[stat];
 
-	(*file) << endl;
+	(*file) << std::endl;
 
 	// If requested, save manager results.
 	if (result_type == RecordAll || result_type == RecordNoTargets || result_type == RecordNoWorkers) {
@@ -499,12 +499,12 @@
 			GetManager(i)->SaveResults(file, access_index, result_type);
 	}
 	// Write current timestamp into the result file
-	(*file) << "'Time Stamp" << endl;
+	(*file) << "'Time Stamp" << std::endl;
 	_ftime(&tb);
 	ptm = localtime(&tb.time);
 	snprintf(acDummy, 64, "%04d-%02d-%02d %02d:%02d:%02d:%003d", ptm->tm_year + 1900,
 		ptm->tm_mon + 1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec, tb.millitm);
-	(*file) << acDummy << endl;
+	(*file) << acDummy << std::endl;
 }
 
 //
@@ -1330,13 +1330,13 @@
 {
 	int mgr_count = ManagerCount();
 
-	outfile << "'MANAGER LIST ==========================" "========================================" << endl;
+	outfile << "'MANAGER LIST ==========================" "========================================" << std::endl;
 
 	for (int counter = 0; counter < mgr_count; counter++)
 		if (!GetManager(counter)->SaveConfig(outfile, save_aspecs, save_targets))
 			return FALSE;	// error saving data - propagate back
 
-	outfile << "'END manager list" << endl;
+	outfile << "'END manager list" << std::endl;
 
 	return TRUE;
 }
@@ -1414,7 +1414,7 @@
 				// ManagerMap::ManagerRetrieve().
 				loadmap.Store(HOSTNAME_LOCAL, 1, "", NULL);
 			} else {
-				// Store an incomplete entry (NULL mgr ptr) in the manager map.
+				// Store an incomplete entry (NULL mgr ptr) in the manager std::map.
 				// This will put the load operation in a waiting state.
 				loadmap.Store(mgr_name, mgr_id, mgr_network, NULL);
 			}
@@ -1429,7 +1429,7 @@
 		mgr = GetManager(0);
 
 		// "SetIfOneManager" means "if there is one manager in the
-		//   load map and it is unassigned, assign it this pointer"
+		//   load std::map and it is unassigned, assign it this pointer"
 		loadmap.SetIfOneManager(mgr);
 	}
 	// Spawn any local managers that are missing.
